#nullable enable
abstract CCVARN.Commands.BaseCommand<TSettings>.ExecuteCore(Spectre.Cli.CommandContext! context, TSettings! settings) -> int
abstract DryIoc.Setup.FactoryType.get -> DryIoc.FactoryType
abstract FastExpressionCompiler.LightExpression.Expression.NodeType.get -> System.Linq.Expressions.ExpressionType
abstract FastExpressionCompiler.LightExpression.MemberBinding.BindingType.get -> System.Linq.Expressions.MemberBindingType
CCVARN.Commands.BaseCommand<TSettings>
CCVARN.Commands.BaseCommand<TSettings>.BaseCommand() -> void
CCVARN.Commands.BaseCommand<TSettings>.Console.get -> CCVARN.Core.IO.IConsoleWriter?
CCVARN.Commands.BaseCommand<TSettings>.Console.set -> void
CCVARN.Commands.BaseCommand<TSettings>.Container.get -> DryIoc.IContainer?
CCVARN.Commands.BaseCommand<TSettings>.Container.set -> void
CCVARN.Commands.BaseCommand<TSettings>.GetRootPath(TSettings! settings) -> string?
CCVARN.Commands.InitCommand
CCVARN.Commands.InitCommand.InitCommand() -> void
CCVARN.Commands.ParseCommand
CCVARN.Commands.ParseCommand.ParseCommand(System.Collections.Generic.IReadOnlyCollection<CCVARN.Core.Exporters.IExporter!>! exporters) -> void
CCVARN.DependencyInject.TypeRegistrar
CCVARN.DependencyInject.TypeRegistrar.Build() -> Spectre.Cli.ITypeResolver!
CCVARN.DependencyInject.TypeRegistrar.Register(System.Type! service, System.Type! implementation) -> void
CCVARN.DependencyInject.TypeRegistrar.RegisterInstance(System.Type! service, object! implementation) -> void
CCVARN.DependencyInject.TypeRegistrar.TypeRegistrar(DryIoc.IContainer! container) -> void
CCVARN.DependencyInject.TypeResolver
CCVARN.DependencyInject.TypeResolver.Resolve(System.Type? type) -> object?
CCVARN.DependencyInject.TypeResolver.TypeResolver(DryIoc.IContainer! container) -> void
CCVARN.IO.ConsoleWriter
CCVARN.IO.ConsoleWriter.AddIndent() -> void
CCVARN.IO.ConsoleWriter.ConsoleWriter() -> void
CCVARN.IO.ConsoleWriter.RemoveIndent() -> void
CCVARN.IO.ConsoleWriter.WriteErrorLine(string! format, params object![]! parameters) -> void
CCVARN.IO.ConsoleWriter.WriteInfo(string! format, params object![]! parameters) -> void
CCVARN.IO.ConsoleWriter.WriteInfoLine(string! format, params object![]! parameters) -> void
CCVARN.IO.ConsoleWriter.WriteInfoLineSafe(string! format, params string![]! parameters) -> void
CCVARN.IO.ConsoleWriter.WriteInfoSafe(string! format, params string![]! parameters) -> void
CCVARN.Options.BaseSettings
CCVARN.Options.BaseSettings.BaseSettings() -> void
CCVARN.Options.BaseSettings.RepositoryRoot.get -> string?
CCVARN.Options.BaseSettings.RepositoryRoot.set -> void
CCVARN.Options.InitOptions
CCVARN.Options.InitOptions.InitOptions() -> void
CCVARN.Options.ParseOption
CCVARN.Options.ParseOption.AdditionalOutputs.get -> string![]!
CCVARN.Options.ParseOption.AdditionalOutputs.set -> void
CCVARN.Options.ParseOption.ExcludeHeaders.get -> bool
CCVARN.Options.ParseOption.ExcludeHeaders.set -> void
CCVARN.Options.ParseOption.Output.get -> string?
CCVARN.Options.ParseOption.Output.set -> void
CCVARN.Options.ParseOption.ParseOption() -> void
const DryIoc.CurrentScopeReuse.DefaultLifespan = 100 -> int
const DryIoc.Rules.DefaultDependencyCountInLambdaToSplitBigObjectGraph = 1024 -> int
const DryIoc.Rules.DefaultDependencyDepthToSplitObjectGraph = 20 -> int
const DryIoc.SingletonReuse.DefaultLifespan = 1000 -> int
const ImTools.GrowingList<T>.DefaultInitialCapacity = 2 -> int
const ImTools.ImHashMapSlots.HASH_MASK_TO_FIND_SLOT = 31 -> int
const ImTools.ImHashMapSlots.SLOT_COUNT_POWER_OF_TWO = 32 -> int
const ImTools.ImMapSlots.KEY_MASK_TO_FIND_SLOT = 31 -> int
const ImTools.ImMapSlots.SLOT_COUNT_POWER_OF_TWO = 32 -> int
const ImTools.Ref.RETRY_COUNT_UNTIL_THROW = 50 -> int
DryIoc.Arg
DryIoc.AsyncExecutionFlowScopeContext
DryIoc.AsyncExecutionFlowScopeContext.AsyncExecutionFlowScopeContext() -> void
DryIoc.AsyncExecutionFlowScopeContext.Dispose() -> void
DryIoc.CompositeScopeName
DryIoc.Container
DryIoc.Container.Container() -> void
DryIoc.Container.Dispose() -> void
DryIoc.Container.IsDisposed.get -> bool
DryIoc.Container.ResolveManyResult
DryIoc.Container.ResolveManyResult.ResolveManyResult() -> void
DryIoc.ContainerException
DryIoc.ContainerTools
DryIoc.ContainerTools.GeneratedExpressions
DryIoc.ContainerTools.GeneratedExpressions.GeneratedExpressions() -> void
DryIoc.CreateScopedValue
DryIoc.CurrentScopeReuse
DryIoc.CurrentScopeReuse.Lifespan.get -> int
DryIoc.DefaultDynamicKey
DryIoc.DefaultKey
DryIoc.DelegateFactory
DryIoc.DynamicRegistration
DryIoc.Error
DryIoc.ErrorCheck
DryIoc.ErrorCheck.InvalidCondition = 1 -> DryIoc.ErrorCheck
DryIoc.ErrorCheck.IsNotOfType = 3 -> DryIoc.ErrorCheck
DryIoc.ErrorCheck.IsNull = 2 -> DryIoc.ErrorCheck
DryIoc.ErrorCheck.OperationThrows = 5 -> DryIoc.ErrorCheck
DryIoc.ErrorCheck.TypeIsNotOfType = 4 -> DryIoc.ErrorCheck
DryIoc.ErrorCheck.Unspecified = 0 -> DryIoc.ErrorCheck
DryIoc.ExpressionFactory
DryIoc.Factory
DryIoc.Factory.Caching.get -> DryIoc.FactoryCaching
DryIoc.Factory.Caching.set -> void
DryIoc.Factory.FactoryID.get -> int
DryIoc.Factory.FactoryType.get -> DryIoc.FactoryType
DryIoc.FactoryCaching
DryIoc.FactoryCaching.Default = 0 -> DryIoc.FactoryCaching
DryIoc.FactoryCaching.DoNotCache = 2 -> DryIoc.FactoryCaching
DryIoc.FactoryCaching.PleaseDontSetDoNotCache = 1 -> DryIoc.FactoryCaching
DryIoc.FactoryDelegate
DryIoc.FactoryDelegate<TService>
DryIoc.FactoryDelegateCompiler
DryIoc.FactoryMethod
DryIoc.FactoryMethodSelector
DryIoc.FactoryType
DryIoc.FactoryType.Decorator = 1 -> DryIoc.FactoryType
DryIoc.FactoryType.Service = 0 -> DryIoc.FactoryType
DryIoc.FactoryType.Wrapper = 2 -> DryIoc.FactoryType
DryIoc.HiddenDisposable
DryIoc.IConcreteFactoryGenerator
DryIoc.IContainer
DryIoc.IConvertibleToExpression
DryIoc.IfAlreadyRegistered
DryIoc.IfAlreadyRegistered.AppendNewImplementation = 4 -> DryIoc.IfAlreadyRegistered
DryIoc.IfAlreadyRegistered.AppendNotKeyed = 0 -> DryIoc.IfAlreadyRegistered
DryIoc.IfAlreadyRegistered.Keep = 2 -> DryIoc.IfAlreadyRegistered
DryIoc.IfAlreadyRegistered.Replace = 3 -> DryIoc.IfAlreadyRegistered
DryIoc.IfAlreadyRegistered.Throw = 1 -> DryIoc.IfAlreadyRegistered
DryIoc.IfUnresolved
DryIoc.IfUnresolved.ReturnDefault = 1 -> DryIoc.IfUnresolved
DryIoc.IfUnresolved.ReturnDefaultIfNotRegistered = 2 -> DryIoc.IfUnresolved
DryIoc.IfUnresolved.Throw = 0 -> DryIoc.IfUnresolved
DryIoc.Interpreter
DryIoc.Interpreter.ParentLambdaArgs
DryIoc.IRegistrator
DryIoc.IResolver
DryIoc.IResolverContext
DryIoc.IResolverContext.IsDisposed.get -> bool
DryIoc.IReuse
DryIoc.IReuse.Lifespan.get -> int
DryIoc.IScope
DryIoc.IScope.IsDisposed.get -> bool
DryIoc.IScopeContext
DryIoc.IScopeName
DryIoc.IServiceInfo
DryIoc.LazyEnumerable<TService>
DryIoc.Made
DryIoc.Made.HasCustomDependencyValue.get -> bool
DryIoc.Made.IsConditional.get -> bool
DryIoc.Made.IsConditionalImplementation.get -> bool
DryIoc.Made.IsImplMemberDependsOnRequest.get -> bool
DryIoc.Made.TypedMade<TService>
DryIoc.Messages.AsyncMessageHandler<M, R>.AsyncMessageHandler() -> void
DryIoc.Messages.EmptyResponse
DryIoc.Messages.EmptyResponse.EmptyResponse() -> void
DryIoc.Messages.IMessage
DryIoc.Messages.IMessage<TResponse>
DryIoc.Messages.IMessageMiddleware<M, R>
DryIoc.Messages.IMessageMiddleware<M, R>.RelativeOrder.get -> int
DryIoc.Messages.MessageExtensions
DryIoc.Messages.MessageMediator
DryIoc.Meta<T, TMetadata>
DryIoc.Meta<T, TMetadata>.Meta(T value, TMetadata metadata) -> void
DryIoc.OpenGenericTypeKey
DryIoc.Parameters
DryIoc.ParameterSelector
DryIoc.ParameterServiceInfo
DryIoc.Portable
DryIoc.PrintTools
DryIoc.PropertiesAndFields
DryIoc.PropertiesAndFields.GetServiceInfo
DryIoc.PropertiesAndFieldsSelector
DryIoc.PropertyOrFieldServiceInfo
DryIoc.PropertyOrFieldServiceInfo.PropertyOrFieldServiceInfo() -> void
DryIoc.ReflectionFactory
DryIoc.ReflectionFactory.GeneratorFactoryID.get -> int
DryIoc.ReflectionTools
DryIoc.ReflectionTools.AsImplementedType
DryIoc.ReflectionTools.AsImplementedType.None = 0 -> DryIoc.ReflectionTools.AsImplementedType
DryIoc.ReflectionTools.AsImplementedType.ObjectType = 2 -> DryIoc.ReflectionTools.AsImplementedType
DryIoc.ReflectionTools.AsImplementedType.SourceType = 1 -> DryIoc.ReflectionTools.AsImplementedType
DryIoc.RegisteredInstanceFactory
DryIoc.Registrator
DryIoc.RegistrySharing
DryIoc.RegistrySharing.CloneAndDropCache = 2 -> DryIoc.RegistrySharing
DryIoc.RegistrySharing.CloneButKeepCache = 1 -> DryIoc.RegistrySharing
DryIoc.RegistrySharing.Share = 0 -> DryIoc.RegistrySharing
DryIoc.Request
DryIoc.Request.CombineDecoratorWithDecoratedFactoryID() -> int
DryIoc.Request.DecoratedFactoryID.get -> int
DryIoc.Request.DependencyCount -> int
DryIoc.Request.DependencyDepth -> int
DryIoc.Request.FactoryID.get -> int
DryIoc.Request.FactoryType.get -> DryIoc.FactoryType
DryIoc.Request.Flags -> DryIoc.RequestFlags
DryIoc.Request.HasRecursiveParent(int factoryID) -> bool
DryIoc.Request.IfUnresolved.get -> DryIoc.IfUnresolved
DryIoc.Request.IsDirectlyWrappedInFunc() -> bool
DryIoc.Request.IsEmpty.get -> bool
DryIoc.Request.IsNestedResolutionCall.get -> bool
DryIoc.Request.IsResolutionCall.get -> bool
DryIoc.Request.IsResolutionRoot.get -> bool
DryIoc.Request.IsSingletonOrDependencyOfSingleton.get -> bool
DryIoc.Request.IsWrappedInFunc() -> bool
DryIoc.Request.IsWrappedInFuncWithArgs() -> bool
DryIoc.Request.OpensResolutionScope.get -> bool
DryIoc.Request.ReuseLifespan.get -> int
DryIoc.Request.ShouldSplitObjectGraph() -> bool
DryIoc.Request.TracksTransientDisposable.get -> bool
DryIoc.RequestFlags
DryIoc.RequestFlags.IsDirectlyWrappedInFunc = 512 -> DryIoc.RequestFlags
DryIoc.RequestFlags.IsGeneratedResolutionDependencyExpression = 256 -> DryIoc.RequestFlags
DryIoc.RequestFlags.IsResolutionCall = 32 -> DryIoc.RequestFlags
DryIoc.RequestFlags.IsSingletonOrDependencyOfSingleton = 8 -> DryIoc.RequestFlags
DryIoc.RequestFlags.IsWrappedInFunc = 16 -> DryIoc.RequestFlags
DryIoc.RequestFlags.OpensResolutionScope = 64 -> DryIoc.RequestFlags
DryIoc.RequestFlags.StopRecursiveDependencyCheck = 128 -> DryIoc.RequestFlags
DryIoc.RequestFlags.TracksTransientDisposable = 2 -> DryIoc.RequestFlags
DryIoc.ResolutionScopeName
DryIoc.ResolveManyBehavior
DryIoc.ResolveManyBehavior.AsFixedArray = 1 -> DryIoc.ResolveManyBehavior
DryIoc.ResolveManyBehavior.AsLazyEnumerable = 0 -> DryIoc.ResolveManyBehavior
DryIoc.Resolver
DryIoc.ResolverContext
DryIoc.Reuse
DryIoc.Rules
DryIoc.Rules.CaptureContainerDisposeStackTrace.get -> bool
DryIoc.Rules.DefaultIfAlreadyRegistered.get -> DryIoc.IfAlreadyRegistered
DryIoc.Rules.DependencyCountInLambdaToSplitBigObjectGraph.get -> int
DryIoc.Rules.DependencyDepthToSplitObjectGraph.get -> int
DryIoc.Rules.DynamicRegistrationProvider
DryIoc.Rules.EagerCachingSingletonForFasterAccess.get -> bool
DryIoc.Rules.FactorySelectorRule
DryIoc.Rules.FuncAndLazyWithoutRegistration.get -> bool
DryIoc.Rules.IgnoringReuseForFuncWithArgs.get -> bool
DryIoc.Rules.ImplicitCheckForReuseMatchingScope.get -> bool
DryIoc.Rules.ItemToExpressionConverterRule
DryIoc.Rules.OverrideRegistrationMade.get -> bool
DryIoc.Rules.ResolveIEnumerableAsLazyEnumerable.get -> bool
DryIoc.Rules.ThrowIfDependencyHasShorterReuseLifespan.get -> bool
DryIoc.Rules.ThrowIfRuntimeStateRequired.get -> bool
DryIoc.Rules.ThrowOnRegisteringDisposableTransient.get -> bool
DryIoc.Rules.TrackingDisposableTransients.get -> bool
DryIoc.Rules.UnknownServiceResolver
DryIoc.Rules.UseDecorateeReuseForDecorators.get -> bool
DryIoc.Rules.UsedForExpressionGeneration.get -> bool
DryIoc.Rules.UsedForValidation.get -> bool
DryIoc.Rules.UseDynamicRegistrationsAsFallbackOnly.get -> bool
DryIoc.Rules.UseFastExpressionCompiler.get -> bool
DryIoc.Rules.UseInterpretation.get -> bool
DryIoc.Rules.UseInterpretationForTheFirstResolution.get -> bool
DryIoc.Rules.VariantGenericTypesInResolvedCollection.get -> bool
DryIoc.Scope
DryIoc.Scope.Dispose() -> void
DryIoc.Scope.IsDisposed.get -> bool
DryIoc.ServiceDetails
DryIoc.ServiceInfo
DryIoc.ServiceInfo.Typed<TService>
DryIoc.ServiceInfo.Typed<TService>.Typed() -> void
DryIoc.ServiceInfoTools
DryIoc.ServiceRegistrationInfo
DryIoc.ServiceRegistrationInfo.AsResolutionRoot.get -> bool
DryIoc.ServiceRegistrationInfo.CompareTo(DryIoc.ServiceRegistrationInfo other) -> int
DryIoc.ServiceRegistrationInfo.FactoryRegistrationOrder.get -> int
DryIoc.ServiceRegistrationInfo.ServiceRegistrationInfo() -> void
DryIoc.SetCurrentScopeHandler
DryIoc.Setup
DryIoc.Setup.AllowDisposableTransient.get -> bool
DryIoc.Setup.AsResolutionCall.get -> bool
DryIoc.Setup.AsResolutionCallForExpressionGeneration.get -> bool
DryIoc.Setup.AsResolutionRoot.get -> bool
DryIoc.Setup.DisposalOrder.get -> int
DryIoc.Setup.OpenResolutionScope.get -> bool
DryIoc.Setup.PreferInSingleServiceResolve.get -> bool
DryIoc.Setup.PreventDisposal.get -> bool
DryIoc.Setup.TrackDisposableTransient.get -> bool
DryIoc.Setup.UseParentReuse.get -> bool
DryIoc.Setup.WeaklyReferenced.get -> bool
DryIoc.SingletonReuse
DryIoc.SingletonReuse.Lifespan.get -> int
DryIoc.SingletonReuse.SingletonReuse() -> void
DryIoc.ThreadScopeContext
DryIoc.ThreadScopeContext.Dispose() -> void
DryIoc.ThreadScopeContext.ThreadScopeContext() -> void
DryIoc.Throw
DryIoc.Throw.GetMatchedExceptionHandler
DryIoc.ThrowInGeneratedCode
DryIoc.WrappersSupport
FastExpressionCompiler.LightExpression.ArgumentsExpression
FastExpressionCompiler.LightExpression.ArrayIndexExpression
FastExpressionCompiler.LightExpression.AssignBinaryExpression
FastExpressionCompiler.LightExpression.BinaryExpression
FastExpressionCompiler.LightExpression.BlockExpression
FastExpressionCompiler.LightExpression.CatchBlock
FastExpressionCompiler.LightExpression.CatchBlock.CatchBlock() -> void
FastExpressionCompiler.LightExpression.CoalesceConversionBinaryExpression
FastExpressionCompiler.LightExpression.CodePrinter
FastExpressionCompiler.LightExpression.CodePrinter.IObjectToCode
FastExpressionCompiler.LightExpression.ConditionalExpression
FastExpressionCompiler.LightExpression.ConstantExpression
FastExpressionCompiler.LightExpression.ConvertWithMethodUnaryExpression
FastExpressionCompiler.LightExpression.DefaultExpression
FastExpressionCompiler.LightExpression.Expression
FastExpressionCompiler.LightExpression.Expression.Expression() -> void
FastExpressionCompiler.LightExpression.Expression<TDelegate>
FastExpressionCompiler.LightExpression.ExpressionCodePrinter
FastExpressionCompiler.LightExpression.ExpressionCompiler
FastExpressionCompiler.LightExpression.ExpressionCompiler.ArrayClosure
FastExpressionCompiler.LightExpression.ExpressionCompiler.ArrayClosureWithNonPassedParams
FastExpressionCompiler.LightExpression.ExpressionCompiler.NestedLambdaWithConstantsAndNestedLambdas
FastExpressionCompiler.LightExpression.FieldExpression
FastExpressionCompiler.LightExpression.FiveArgumentsMethodCallExpression
FastExpressionCompiler.LightExpression.FiveArgumentsNewExpression
FastExpressionCompiler.LightExpression.FourArgumentsMethodCallExpression
FastExpressionCompiler.LightExpression.FourArgumentsNewExpression
FastExpressionCompiler.LightExpression.GotoExpression
FastExpressionCompiler.LightExpression.ILGeneratorHacks
FastExpressionCompiler.LightExpression.IndexExpression
FastExpressionCompiler.LightExpression.InstanceFiveArgumentsMethodCallExpression
FastExpressionCompiler.LightExpression.InstanceFourArgumentsMethodCallExpression
FastExpressionCompiler.LightExpression.InstanceManyArgumentsMethodCallExpression
FastExpressionCompiler.LightExpression.InstanceMethodCallExpression
FastExpressionCompiler.LightExpression.InstanceOneArgumentMethodCallExpression
FastExpressionCompiler.LightExpression.InstanceThreeArgumentsMethodCallExpression
FastExpressionCompiler.LightExpression.InstanceTwoArgumentsMethodCallExpression
FastExpressionCompiler.LightExpression.InvocationExpression
FastExpressionCompiler.LightExpression.LabelExpression
FastExpressionCompiler.LightExpression.LambdaExpression
FastExpressionCompiler.LightExpression.LoopExpression
FastExpressionCompiler.LightExpression.ManyArgumentsMethodCallExpression
FastExpressionCompiler.LightExpression.ManyArgumentsNewExpression
FastExpressionCompiler.LightExpression.ManyParametersExpression<TDelegate>
FastExpressionCompiler.LightExpression.ManyParametersLambdaExpression
FastExpressionCompiler.LightExpression.MemberAssignment
FastExpressionCompiler.LightExpression.MemberBinding
FastExpressionCompiler.LightExpression.MemberExpression
FastExpressionCompiler.LightExpression.MemberInitExpression
FastExpressionCompiler.LightExpression.MethodCallExpression
FastExpressionCompiler.LightExpression.NewArrayExpression
FastExpressionCompiler.LightExpression.NewExpression
FastExpressionCompiler.LightExpression.NewValueTypeExpression
FastExpressionCompiler.LightExpression.OneArgumentMethodCallExpression
FastExpressionCompiler.LightExpression.OneArgumentNewExpression
FastExpressionCompiler.LightExpression.OneVariableTwoExpressionBlockExpression
FastExpressionCompiler.LightExpression.ParameterExpression
FastExpressionCompiler.LightExpression.PropertyExpression
FastExpressionCompiler.LightExpression.SimpleBinaryExpression
FastExpressionCompiler.LightExpression.SwitchCase
FastExpressionCompiler.LightExpression.SwitchCase.SwitchCase() -> void
FastExpressionCompiler.LightExpression.SwitchExpression
FastExpressionCompiler.LightExpression.ThreeArgumentsMethodCallExpression
FastExpressionCompiler.LightExpression.ThreeArgumentsNewExpression
FastExpressionCompiler.LightExpression.TryExpression
FastExpressionCompiler.LightExpression.TwoArgumentsMethodCallExpression
FastExpressionCompiler.LightExpression.TwoArgumentsNewExpression
FastExpressionCompiler.LightExpression.TypeBinaryExpression
FastExpressionCompiler.LightExpression.TypedConstantExpression
FastExpressionCompiler.LightExpression.TypedConstantExpression<T>
FastExpressionCompiler.LightExpression.TypedUnaryExpression
FastExpressionCompiler.LightExpression.TypedUnaryExpression<T>
FastExpressionCompiler.LightExpression.UnaryExpression
ImTools.ArrayTools
ImTools.Box<TBox, T>.Box() -> void
ImTools.Box<TBox, T>.Value.get -> T
ImTools.Fun
ImTools.GrowingList<T>
ImTools.GrowingList<T>.Count -> int
ImTools.GrowingList<T>.GrowingList() -> void
ImTools.GrowingList<T>.Pop() -> void
ImTools.GrowingList<T>.PushSlot() -> T
ImTools.GrowingList<T>.PushSlot(T item) -> void
ImTools.Hasher
ImTools.I<T>
ImTools.I<T>.Value.get -> T
ImTools.IFoldReducer<T, S>
ImTools.IFoldReducer<T, S>.Reduce(T x, S state) -> S
ImTools.ImHashMap
ImTools.ImHashMap<K, V>
ImTools.ImHashMap<K, V>.ContainsConflictedData(K key) -> bool
ImTools.ImHashMap<K, V>.GetConflictedValueOrDefault(K key, V defaultValue) -> V
ImTools.ImHashMap<K, V>.Hash.get -> int
ImTools.ImHashMap<K, V>.Height -> int
ImTools.ImHashMap<K, V>.ImHashMap(int hash, K key) -> void
ImTools.ImHashMap<K, V>.ImHashMap(int hash, K key, V value) -> void
ImTools.ImHashMap<K, V>.IsEmpty.get -> bool
ImTools.ImHashMap<K, V>.Key.get -> K
ImTools.ImHashMap<K, V>.TryFindConflictedValue(K key, out V value) -> bool
ImTools.ImHashMap<K, V>.Value.get -> V
ImTools.ImHashMapConflicts<K, V>
ImTools.ImHashMapEntry<K, V>
ImTools.ImHashMapEntry<K, V>.ImHashMapEntry(int hash, K key) -> void
ImTools.ImHashMapEntry<K, V>.ImHashMapEntry(int hash, K key, V value) -> void
ImTools.ImHashMapEntry<K, V>.Value -> V
ImTools.ImHashMapSlots
ImTools.ImList
ImTools.ImList<T>
ImTools.ImList<T>.IsEmpty.get -> bool
ImTools.ImMap
ImTools.ImMap.KValue<K>
ImTools.ImMap.KValue<K>.Key -> K
ImTools.ImMap.KValue<K>.KValue() -> void
ImTools.ImMap<V>
ImTools.ImMap<V>.ImMap() -> void
ImTools.ImMap<V>.IsEmpty.get -> bool
ImTools.ImMapBranch<V>
ImTools.ImMapEntry<V>
ImTools.ImMapEntry<V>.ImMapEntry(int key) -> void
ImTools.ImMapEntry<V>.ImMapEntry(int key, V value) -> void
ImTools.ImMapEntry<V>.Value -> V
ImTools.ImMapSlots
ImTools.ImMapTree<V>
ImTools.ImMapTree<V>.TreeHeight -> int
ImTools.ImZipper
ImTools.ImZipper<T>
ImTools.ImZipper<T>.IsEmpty.get -> bool
ImTools.IPrintable
ImTools.Item<TItem, T>.item
ImTools.Item<TItem, T>.Item() -> void
ImTools.Item<TItem, T>.item.item() -> void
ImTools.Item<TItem, T>.item.item(T x) -> void
ImTools.Item<TItem, T>.item.Value.get -> T
ImTools.Item<TItem>.item
ImTools.Item<TItem>.Item() -> void
ImTools.Item<TItem>.item.item() -> void
ImTools.KeyValuePair
ImTools.KV
ImTools.KV<K, V>
ImTools.KV<K, V>.KV(K key, V value) -> void
ImTools.Lazy
ImTools.Opt<T>
ImTools.Opt<T>.Opt() -> void
ImTools.Opt<T>.Opt(T value) -> void
ImTools.Opt<T>.OrDefault(T defaultValue = default(T)) -> T
ImTools.Ref
ImTools.StackPool<T>.StackPool() -> void
ImTools.U<T1, T2, T3, T4, T5, T6, T7>
ImTools.U<T1, T2, T3, T4, T5, T6, T7>.U() -> void
ImTools.U<T1, T2, T3, T4, T5, T6>
ImTools.U<T1, T2, T3, T4, T5, T6>.U() -> void
ImTools.U<T1, T2, T3, T4, T5>
ImTools.U<T1, T2, T3, T4, T5>.U() -> void
ImTools.U<T1, T2, T3, T4>
ImTools.U<T1, T2, T3, T4>.U() -> void
ImTools.U<T1, T2, T3>
ImTools.U<T1, T2, T3>.U() -> void
ImTools.U<T1, T2>
ImTools.U<T1, T2>.U() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case1
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case1.case1() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case1.case1(T1 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case1.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case1 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case1.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case1.Value.get -> T1
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case10
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case10.case10() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case10.case10(T10 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case10.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case10 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case10.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case10.Value.get -> T10
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case2
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case2.case2() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case2.case2(T2 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case2.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case2 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case2.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case2.Value.get -> T2
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case3
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case3.case3() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case3.case3(T3 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case3.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case3 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case3.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case3.Value.get -> T3
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case4
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case4.case4() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case4.case4(T4 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case4.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case4 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case4.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case4.Value.get -> T4
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case5
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case5.case5() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case5.case5(T5 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case5.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case5 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case5.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case5.Value.get -> T5
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case6
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case6.case6() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case6.case6(T6 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case6.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case6 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case6.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case6.Value.get -> T6
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case7
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case7.case7() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case7.case7(T7 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case7.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case7 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case7.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case7.Value.get -> T7
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case8
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case8.case8() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case8.case8(T8 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case8.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case8 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case8.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case8.Value.get -> T8
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case9
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case9.case9() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case9.case9(T9 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case9.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case9 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case9.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case9.Value.get -> T9
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag.Case1 = 0 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag.Case10 = 9 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag.Case2 = 1 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag.Case3 = 2 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag.Case4 = 3 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag.Case5 = 4 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag.Case6 = 5 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag.Case7 = 6 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag.Case8 = 7 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag.Case9 = 8 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.union
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Union() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.union.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case1
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case1.case1() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case1.case1(T1 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case1.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case1 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case1.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case1.Value.get -> T1
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case2
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case2.case2() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case2.case2(T2 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case2.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case2 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case2.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case2.Value.get -> T2
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case3
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case3.case3() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case3.case3(T3 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case3.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case3 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case3.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case3.Value.get -> T3
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case4
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case4.case4() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case4.case4(T4 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case4.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case4 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case4.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case4.Value.get -> T4
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case5
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case5.case5() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case5.case5(T5 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case5.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case5 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case5.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case5.Value.get -> T5
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case6
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case6.case6() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case6.case6(T6 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case6.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case6 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case6.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case6.Value.get -> T6
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case7
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case7.case7() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case7.case7(T7 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case7.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case7 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case7.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case7.Value.get -> T7
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case8
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case8.case8() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case8.case8(T8 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case8.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case8 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case8.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case8.Value.get -> T8
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case9
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case9.case9() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case9.case9(T9 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case9.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case9 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case9.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case9.Value.get -> T9
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag.Case1 = 0 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag.Case2 = 1 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag.Case3 = 2 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag.Case4 = 3 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag.Case5 = 4 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag.Case6 = 5 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag.Case7 = 6 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag.Case8 = 7 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag.Case9 = 8 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.union
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Union() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.union.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case1
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case1.case1() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case1.case1(T1 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case1.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case1 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case1.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case1.Value.get -> T1
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case2
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case2.case2() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case2.case2(T2 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case2.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case2 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case2.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case2.Value.get -> T2
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case3
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case3.case3() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case3.case3(T3 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case3.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case3 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case3.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case3.Value.get -> T3
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case4
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case4.case4() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case4.case4(T4 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case4.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case4 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case4.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case4.Value.get -> T4
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case5
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case5.case5() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case5.case5(T5 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case5.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case5 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case5.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case5.Value.get -> T5
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case6
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case6.case6() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case6.case6(T6 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case6.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case6 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case6.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case6.Value.get -> T6
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case7
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case7.case7() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case7.case7(T7 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case7.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case7 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case7.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case7.Value.get -> T7
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case8
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case8.case8() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case8.case8(T8 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case8.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case8 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case8.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case8.Value.get -> T8
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag.Case1 = 0 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag.Case2 = 1 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag.Case3 = 2 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag.Case4 = 3 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag.Case5 = 4 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag.Case6 = 5 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag.Case7 = 6 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag.Case8 = 7 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.union
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Union() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.union.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case1
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case1.case1() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case1.case1(T1 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case1.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case1 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case1.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case1.Value.get -> T1
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case2
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case2.case2() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case2.case2(T2 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case2.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case2 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case2.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case2.Value.get -> T2
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case3
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case3.case3() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case3.case3(T3 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case3.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case3 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case3.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case3.Value.get -> T3
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case4
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case4.case4() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case4.case4(T4 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case4.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case4 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case4.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case4.Value.get -> T4
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case5
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case5.case5() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case5.case5(T5 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case5.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case5 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case5.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case5.Value.get -> T5
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case6
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case6.case6() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case6.case6(T6 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case6.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case6 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case6.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case6.Value.get -> T6
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case7
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case7.case7() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case7.case7(T7 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case7.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case7 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case7.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case7.Value.get -> T7
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag.Case1 = 0 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag.Case2 = 1 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag.Case3 = 2 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag.Case4 = 3 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag.Case5 = 4 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag.Case6 = 5 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag.Case7 = 6 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.union
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Union() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.union.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case1
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case1.case1() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case1.case1(T1 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case1.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case1 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case1.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case1.Value.get -> T1
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case2
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case2.case2() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case2.case2(T2 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case2.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case2 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case2.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case2.Value.get -> T2
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case3
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case3.case3() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case3.case3(T3 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case3.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case3 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case3.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case3.Value.get -> T3
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case4
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case4.case4() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case4.case4(T4 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case4.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case4 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case4.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case4.Value.get -> T4
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case5
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case5.case5() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case5.case5(T5 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case5.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case5 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case5.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case5.Value.get -> T5
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case6
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case6.case6() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case6.case6(T6 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case6.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case6 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case6.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case6.Value.get -> T6
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Tag.Case1 = 0 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Tag.Case2 = 1 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Tag.Case3 = 2 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Tag.Case4 = 3 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Tag.Case5 = 4 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Tag.Case6 = 5 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.union
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Union() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.union.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5>
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case1
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case1.case1() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case1.case1(T1 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case1.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case1 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case1.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case1.Value.get -> T1
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case2
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case2.case2() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case2.case2(T2 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case2.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case2 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case2.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case2.Value.get -> T2
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case3
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case3.case3() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case3.case3(T3 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case3.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case3 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case3.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case3.Value.get -> T3
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case4
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case4.case4() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case4.case4(T4 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case4.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case4 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case4.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case4.Value.get -> T4
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case5
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case5.case5() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case5.case5(T5 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case5.Equals(ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case5 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case5.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case5.Value.get -> T5
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Tag.Case1 = 0 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Tag.Case2 = 1 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Tag.Case3 = 2 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Tag.Case4 = 3 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Tag.Case5 = 4 -> ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.union
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Union() -> void
ImTools.Union<TUnion, T1, T2, T3, T4, T5>.union.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4>
ImTools.Union<TUnion, T1, T2, T3, T4>.case1
ImTools.Union<TUnion, T1, T2, T3, T4>.case1.case1() -> void
ImTools.Union<TUnion, T1, T2, T3, T4>.case1.case1(T1 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4>.case1.Equals(ImTools.Union<TUnion, T1, T2, T3, T4>.case1 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4>.case1.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4>.case1.Value.get -> T1
ImTools.Union<TUnion, T1, T2, T3, T4>.case2
ImTools.Union<TUnion, T1, T2, T3, T4>.case2.case2() -> void
ImTools.Union<TUnion, T1, T2, T3, T4>.case2.case2(T2 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4>.case2.Equals(ImTools.Union<TUnion, T1, T2, T3, T4>.case2 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4>.case2.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4>.case2.Value.get -> T2
ImTools.Union<TUnion, T1, T2, T3, T4>.case3
ImTools.Union<TUnion, T1, T2, T3, T4>.case3.case3() -> void
ImTools.Union<TUnion, T1, T2, T3, T4>.case3.case3(T3 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4>.case3.Equals(ImTools.Union<TUnion, T1, T2, T3, T4>.case3 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4>.case3.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4>.case3.Value.get -> T3
ImTools.Union<TUnion, T1, T2, T3, T4>.case4
ImTools.Union<TUnion, T1, T2, T3, T4>.case4.case4() -> void
ImTools.Union<TUnion, T1, T2, T3, T4>.case4.case4(T4 x) -> void
ImTools.Union<TUnion, T1, T2, T3, T4>.case4.Equals(ImTools.Union<TUnion, T1, T2, T3, T4>.case4 other) -> bool
ImTools.Union<TUnion, T1, T2, T3, T4>.case4.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4>.case4.Value.get -> T4
ImTools.Union<TUnion, T1, T2, T3, T4>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4>.Tag.Case1 = 0 -> ImTools.Union<TUnion, T1, T2, T3, T4>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4>.Tag.Case2 = 1 -> ImTools.Union<TUnion, T1, T2, T3, T4>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4>.Tag.Case3 = 2 -> ImTools.Union<TUnion, T1, T2, T3, T4>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4>.Tag.Case4 = 3 -> ImTools.Union<TUnion, T1, T2, T3, T4>.Tag
ImTools.Union<TUnion, T1, T2, T3, T4>.union
ImTools.Union<TUnion, T1, T2, T3, T4>.Union() -> void
ImTools.Union<TUnion, T1, T2, T3, T4>.union.Tag.get -> ImTools.Union<TUnion, T1, T2, T3, T4>.Tag
ImTools.Union<TUnion, T1, T2, T3>
ImTools.Union<TUnion, T1, T2, T3>.case1
ImTools.Union<TUnion, T1, T2, T3>.case1.case1() -> void
ImTools.Union<TUnion, T1, T2, T3>.case1.case1(T1 x) -> void
ImTools.Union<TUnion, T1, T2, T3>.case1.Equals(ImTools.Union<TUnion, T1, T2, T3>.case1 other) -> bool
ImTools.Union<TUnion, T1, T2, T3>.case1.Tag.get -> ImTools.Union<TUnion, T1, T2, T3>.Tag
ImTools.Union<TUnion, T1, T2, T3>.case1.Value.get -> T1
ImTools.Union<TUnion, T1, T2, T3>.case2
ImTools.Union<TUnion, T1, T2, T3>.case2.case2() -> void
ImTools.Union<TUnion, T1, T2, T3>.case2.case2(T2 x) -> void
ImTools.Union<TUnion, T1, T2, T3>.case2.Equals(ImTools.Union<TUnion, T1, T2, T3>.case2 other) -> bool
ImTools.Union<TUnion, T1, T2, T3>.case2.Tag.get -> ImTools.Union<TUnion, T1, T2, T3>.Tag
ImTools.Union<TUnion, T1, T2, T3>.case2.Value.get -> T2
ImTools.Union<TUnion, T1, T2, T3>.case3
ImTools.Union<TUnion, T1, T2, T3>.case3.case3() -> void
ImTools.Union<TUnion, T1, T2, T3>.case3.case3(T3 x) -> void
ImTools.Union<TUnion, T1, T2, T3>.case3.Equals(ImTools.Union<TUnion, T1, T2, T3>.case3 other) -> bool
ImTools.Union<TUnion, T1, T2, T3>.case3.Tag.get -> ImTools.Union<TUnion, T1, T2, T3>.Tag
ImTools.Union<TUnion, T1, T2, T3>.case3.Value.get -> T3
ImTools.Union<TUnion, T1, T2, T3>.Tag
ImTools.Union<TUnion, T1, T2, T3>.Tag.Case1 = 0 -> ImTools.Union<TUnion, T1, T2, T3>.Tag
ImTools.Union<TUnion, T1, T2, T3>.Tag.Case2 = 1 -> ImTools.Union<TUnion, T1, T2, T3>.Tag
ImTools.Union<TUnion, T1, T2, T3>.Tag.Case3 = 2 -> ImTools.Union<TUnion, T1, T2, T3>.Tag
ImTools.Union<TUnion, T1, T2, T3>.union
ImTools.Union<TUnion, T1, T2, T3>.Union() -> void
ImTools.Union<TUnion, T1, T2, T3>.union.Tag.get -> ImTools.Union<TUnion, T1, T2, T3>.Tag
ImTools.Union<TUnion, T1, T2>
ImTools.Union<TUnion, T1, T2>.case1
ImTools.Union<TUnion, T1, T2>.case1.case1() -> void
ImTools.Union<TUnion, T1, T2>.case1.case1(T1 x) -> void
ImTools.Union<TUnion, T1, T2>.case1.Equals(ImTools.Union<TUnion, T1, T2>.case1 other) -> bool
ImTools.Union<TUnion, T1, T2>.case1.Tag.get -> ImTools.Union<TUnion, T1, T2>.Tag
ImTools.Union<TUnion, T1, T2>.case1.Value.get -> T1
ImTools.Union<TUnion, T1, T2>.case2
ImTools.Union<TUnion, T1, T2>.case2.case2() -> void
ImTools.Union<TUnion, T1, T2>.case2.case2(T2 x) -> void
ImTools.Union<TUnion, T1, T2>.case2.Equals(ImTools.Union<TUnion, T1, T2>.case2 other) -> bool
ImTools.Union<TUnion, T1, T2>.case2.Tag.get -> ImTools.Union<TUnion, T1, T2>.Tag
ImTools.Union<TUnion, T1, T2>.case2.Value.get -> T2
ImTools.Union<TUnion, T1, T2>.Tag
ImTools.Union<TUnion, T1, T2>.Tag.Case1 = 0 -> ImTools.Union<TUnion, T1, T2>.Tag
ImTools.Union<TUnion, T1, T2>.Tag.Case2 = 1 -> ImTools.Union<TUnion, T1, T2>.Tag
ImTools.Union<TUnion, T1, T2>.union
ImTools.Union<TUnion, T1, T2>.Union() -> void
ImTools.Union<TUnion, T1, T2>.union.Tag.get -> ImTools.Union<TUnion, T1, T2>.Tag
ImTools.UnionTools
ImTools.Unit
ImTools.Unit.Equals(ImTools.Unit other) -> bool
ImTools.Unit.Unit() -> void
ImTools.Update<K, V>
ImTools.Update<V>
override CCVARN.Commands.BaseCommand<TSettings>.Validate(Spectre.Cli.CommandContext! context, TSettings! settings) -> Spectre.Cli.ValidationResult!
override CCVARN.Commands.ParseCommand.Validate(Spectre.Cli.CommandContext! context, CCVARN.Options.ParseOption! settings) -> Spectre.Cli.ValidationResult!
override CCVARN.Options.BaseSettings.Validate() -> Spectre.Cli.ValidationResult!
override CCVARN.Options.ParseOption.Validate() -> Spectre.Cli.ValidationResult!
override DryIoc.DefaultDynamicKey.GetHashCode() -> int
override DryIoc.DefaultKey.GetHashCode() -> int
override DryIoc.DelegateFactory.HasRuntimeState.get -> bool
override DryIoc.OpenGenericTypeKey.GetHashCode() -> int
override DryIoc.ReflectionFactory.CanAccessImplementationType.get -> bool
override DryIoc.ReflectionFactory.RegistrationOrder.get -> int
override DryIoc.RegisteredInstanceFactory.HasRuntimeState.get -> bool
override DryIoc.Request.GetHashCode() -> int
override FastExpressionCompiler.LightExpression.BinaryExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override FastExpressionCompiler.LightExpression.BlockExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override FastExpressionCompiler.LightExpression.ConditionalExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override FastExpressionCompiler.LightExpression.ConstantExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override FastExpressionCompiler.LightExpression.DefaultExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override FastExpressionCompiler.LightExpression.FiveArgumentsMethodCallExpression.FewArgumentCount.get -> int
override FastExpressionCompiler.LightExpression.FiveArgumentsNewExpression.FewArgumentCount.get -> int
override FastExpressionCompiler.LightExpression.FourArgumentsMethodCallExpression.FewArgumentCount.get -> int
override FastExpressionCompiler.LightExpression.FourArgumentsNewExpression.FewArgumentCount.get -> int
override FastExpressionCompiler.LightExpression.GotoExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override FastExpressionCompiler.LightExpression.IndexExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override FastExpressionCompiler.LightExpression.InvocationExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override FastExpressionCompiler.LightExpression.LabelExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override FastExpressionCompiler.LightExpression.LambdaExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override FastExpressionCompiler.LightExpression.LoopExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override FastExpressionCompiler.LightExpression.ManyArgumentsMethodCallExpression.FewArgumentCount.get -> int
override FastExpressionCompiler.LightExpression.ManyArgumentsNewExpression.FewArgumentCount.get -> int
override FastExpressionCompiler.LightExpression.MemberAssignment.BindingType.get -> System.Linq.Expressions.MemberBindingType
override FastExpressionCompiler.LightExpression.MemberExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override FastExpressionCompiler.LightExpression.MemberInitExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override FastExpressionCompiler.LightExpression.MethodCallExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override FastExpressionCompiler.LightExpression.NewArrayExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override FastExpressionCompiler.LightExpression.NewExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override FastExpressionCompiler.LightExpression.OneArgumentMethodCallExpression.FewArgumentCount.get -> int
override FastExpressionCompiler.LightExpression.OneArgumentNewExpression.FewArgumentCount.get -> int
override FastExpressionCompiler.LightExpression.OneVariableTwoExpressionBlockExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override FastExpressionCompiler.LightExpression.ParameterExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override FastExpressionCompiler.LightExpression.SwitchExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override FastExpressionCompiler.LightExpression.ThreeArgumentsMethodCallExpression.FewArgumentCount.get -> int
override FastExpressionCompiler.LightExpression.ThreeArgumentsNewExpression.FewArgumentCount.get -> int
override FastExpressionCompiler.LightExpression.TryExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override FastExpressionCompiler.LightExpression.TwoArgumentsMethodCallExpression.FewArgumentCount.get -> int
override FastExpressionCompiler.LightExpression.TwoArgumentsNewExpression.FewArgumentCount.get -> int
override FastExpressionCompiler.LightExpression.TypeBinaryExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override FastExpressionCompiler.LightExpression.UnaryExpression.NodeType.get -> System.Linq.Expressions.ExpressionType
override ImTools.Box<TBox, T>.GetHashCode() -> int
override ImTools.ImMapBranch<V>.Height.get -> int
override ImTools.ImMapEntry<V>.Height.get -> int
override ImTools.ImMapTree<V>.Height.get -> int
override ImTools.Item<TItem, T>.item.GetHashCode() -> int
override ImTools.Item<TItem>.item.GetHashCode() -> int
override ImTools.KV<K, V>.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case1.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case10.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case2.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case3.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case4.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case5.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case6.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case7.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case8.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case9.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case1.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case2.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case3.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case4.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case5.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case6.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case7.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case8.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case9.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case1.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case2.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case3.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case4.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case5.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case6.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case7.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case8.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case1.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case2.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case3.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case4.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case5.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case6.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case7.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case1.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case2.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case3.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case4.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case5.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case6.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case1.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case2.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case3.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case4.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case5.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4>.case1.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4>.case2.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4>.case3.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3, T4>.case4.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3>.case1.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3>.case2.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2, T3>.case3.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2>.case1.GetHashCode() -> int
override ImTools.Union<TUnion, T1, T2>.case2.GetHashCode() -> int
override ImTools.Unit.GetHashCode() -> int
override sealed CCVARN.Commands.BaseCommand<TSettings>.Execute(Spectre.Cli.CommandContext! context, TSettings! settings) -> int
readonly DryIoc.ContainerException.Error -> int
readonly DryIoc.CurrentScopeReuse.ScopedOrSingleton -> bool
readonly DryIoc.DefaultDynamicKey.RegistrationOrder -> int
readonly DryIoc.DefaultKey.RegistrationOrder -> int
readonly DryIoc.DynamicRegistration.IfAlreadyRegistered -> DryIoc.IfAlreadyRegistered
readonly DryIoc.Meta<T, TMetadata>.Metadata -> TMetadata
readonly DryIoc.Meta<T, TMetadata>.Value -> T
readonly DryIoc.ServiceDetails.HasCustomValue -> bool
readonly DryIoc.ServiceDetails.IfUnresolved -> DryIoc.IfUnresolved
readonly FastExpressionCompiler.LightExpression.GotoExpression.Kind -> System.Linq.Expressions.GotoExpressionKind
readonly FastExpressionCompiler.LightExpression.ParameterExpression.IsByRef -> bool
readonly ImTools.ImHashMapEntry<K, V>.Hash -> int
readonly ImTools.ImHashMapEntry<K, V>.Key -> K
readonly ImTools.ImList<T>.Head -> T
readonly ImTools.ImMapEntry<V>.Key -> int
readonly ImTools.ImZipper<T>.Count -> int
readonly ImTools.ImZipper<T>.Focus -> T
readonly ImTools.ImZipper<T>.Index -> int
readonly ImTools.Item<TItem, T>.item.Item -> T
readonly ImTools.KV<K, V>.Key -> K
readonly ImTools.KV<K, V>.Value -> V
readonly ImTools.Opt<T>.HasValue -> bool
readonly ImTools.Opt<T>.Value -> T
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case1.Case -> T1
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case10.Case -> T10
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case2.Case -> T2
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case3.Case -> T3
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case4.Case -> T4
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case5.Case -> T5
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case6.Case -> T6
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case7.Case -> T7
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case8.Case -> T8
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case9.Case -> T9
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case1.Case -> T1
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case2.Case -> T2
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case3.Case -> T3
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case4.Case -> T4
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case5.Case -> T5
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case6.Case -> T6
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case7.Case -> T7
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case8.Case -> T8
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case9.Case -> T9
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case1.Case -> T1
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case2.Case -> T2
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case3.Case -> T3
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case4.Case -> T4
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case5.Case -> T5
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case6.Case -> T6
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case7.Case -> T7
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case8.Case -> T8
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case1.Case -> T1
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case2.Case -> T2
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case3.Case -> T3
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case4.Case -> T4
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case5.Case -> T5
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case6.Case -> T6
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case7.Case -> T7
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case1.Case -> T1
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case2.Case -> T2
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case3.Case -> T3
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case4.Case -> T4
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case5.Case -> T5
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case6.Case -> T6
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case1.Case -> T1
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case2.Case -> T2
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case3.Case -> T3
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case4.Case -> T4
readonly ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case5.Case -> T5
readonly ImTools.Union<TUnion, T1, T2, T3, T4>.case1.Case -> T1
readonly ImTools.Union<TUnion, T1, T2, T3, T4>.case2.Case -> T2
readonly ImTools.Union<TUnion, T1, T2, T3, T4>.case3.Case -> T3
readonly ImTools.Union<TUnion, T1, T2, T3, T4>.case4.Case -> T4
readonly ImTools.Union<TUnion, T1, T2, T3>.case1.Case -> T1
readonly ImTools.Union<TUnion, T1, T2, T3>.case2.Case -> T2
readonly ImTools.Union<TUnion, T1, T2, T3>.case3.Case -> T3
readonly ImTools.Union<TUnion, T1, T2>.case1.Case -> T1
readonly ImTools.Union<TUnion, T1, T2>.case2.Case -> T2
static DryIoc.Arg.Index<T>(int argIndex) -> T
static DryIoc.Arg.Of<TRequired>() -> TRequired
static DryIoc.Arg.Of<TRequired>(DryIoc.IfUnresolved ifUnresolved) -> TRequired
static DryIoc.Arg.Of<TRequired>(TRequired defaultValue, DryIoc.IfUnresolved ifUnresolved) -> TRequired
static DryIoc.Arg.Of<TService, TRequired>() -> TService
static DryIoc.Arg.Of<TService, TRequired>(DryIoc.IfUnresolved ifUnresolved) -> TService
static DryIoc.ContainerTools.DefaultValidateCondition(DryIoc.ServiceRegistrationInfo reg) -> bool
static DryIoc.Factory.GetNextID() -> int
static DryIoc.Portable.GetCurrentManagedThreadID() -> int
static ImTools.Fun.Always<T>(T _) -> bool
static ImTools.Fun.Id<T>(T x) -> T
static ImTools.Fun.ToFunc<T, R>(this R result, T ignoredArg) -> R
static ImTools.Hasher.Combine(int h1, int h2) -> int
static ImTools.Hasher.Combine<T1, T2>(T1 a, T2 b) -> int
static ImTools.KeyValuePair.Pair<K, V>(this K key, V value) -> System.Collections.Generic.KeyValuePair<K, V>
static ImTools.Opt<T>.implicit operator ImTools.Opt<T>(T value) -> ImTools.Opt<T>
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case1.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case1(T1 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case1
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case10.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case10(T10 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case10
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case2.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case2(T2 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case2
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case3.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case3(T3 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case3
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case4.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case4(T4 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case4
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case5.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case5(T5 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case5
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case6.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case6(T6 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case6
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case7.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case7(T7 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case7
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case8.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case8(T8 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case8
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case9.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case9(T9 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case9
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case1.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case1(T1 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case1
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case2.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case2(T2 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case2
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case3.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case3(T3 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case3
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case4.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case4(T4 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case4
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case5.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case5(T5 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case5
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case6.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case6(T6 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case6
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case7.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case7(T7 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case7
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case8.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case8(T8 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case8
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case9.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case9(T9 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case9
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case1.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case1(T1 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case1
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case2.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case2(T2 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case2
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case3.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case3(T3 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case3
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case4.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case4(T4 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case4
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case5.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case5(T5 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case5
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case6.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case6(T6 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case6
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case7.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case7(T7 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case7
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case8.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case8(T8 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case8
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case1.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case1(T1 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case1
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case2.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case2(T2 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case2
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case3.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case3(T3 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case3
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case4.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case4(T4 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case4
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case5.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case5(T5 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case5
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case6.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case6(T6 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case6
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case7.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case7(T7 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case7
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case1.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case1(T1 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case1
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case2.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case2(T2 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case2
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case3.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case3(T3 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case3
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case4.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case4(T4 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case4
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case5.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case5(T5 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case5
static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case6.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case6(T6 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case6
static ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case1.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case1(T1 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case1
static ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case2.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case2(T2 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case2
static ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case3.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case3(T3 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case3
static ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case4.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case4(T4 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case4
static ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case5.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case5(T5 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case5
static ImTools.Union<TUnion, T1, T2, T3, T4>.case1.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4>.case1(T1 x) -> ImTools.Union<TUnion, T1, T2, T3, T4>.case1
static ImTools.Union<TUnion, T1, T2, T3, T4>.case2.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4>.case2(T2 x) -> ImTools.Union<TUnion, T1, T2, T3, T4>.case2
static ImTools.Union<TUnion, T1, T2, T3, T4>.case3.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4>.case3(T3 x) -> ImTools.Union<TUnion, T1, T2, T3, T4>.case3
static ImTools.Union<TUnion, T1, T2, T3, T4>.case4.implicit operator ImTools.Union<TUnion, T1, T2, T3, T4>.case4(T4 x) -> ImTools.Union<TUnion, T1, T2, T3, T4>.case4
static ImTools.Union<TUnion, T1, T2, T3>.case1.implicit operator ImTools.Union<TUnion, T1, T2, T3>.case1(T1 x) -> ImTools.Union<TUnion, T1, T2, T3>.case1
static ImTools.Union<TUnion, T1, T2, T3>.case2.implicit operator ImTools.Union<TUnion, T1, T2, T3>.case2(T2 x) -> ImTools.Union<TUnion, T1, T2, T3>.case2
static ImTools.Union<TUnion, T1, T2, T3>.case3.implicit operator ImTools.Union<TUnion, T1, T2, T3>.case3(T3 x) -> ImTools.Union<TUnion, T1, T2, T3>.case3
static ImTools.Union<TUnion, T1, T2>.case1.implicit operator ImTools.Union<TUnion, T1, T2>.case1(T1 x) -> ImTools.Union<TUnion, T1, T2>.case1
static ImTools.Union<TUnion, T1, T2>.case2.implicit operator ImTools.Union<TUnion, T1, T2>.case2(T2 x) -> ImTools.Union<TUnion, T1, T2>.case2
static readonly DryIoc.Error.ArgValueIndexIsOutOfProvidedArgValues -> int
static readonly DryIoc.Error.ArgValueIndexIsProvidedButNoArgValues -> int
static readonly DryIoc.Error.ContainerIsDisposed -> int
static readonly DryIoc.Error.DecoratorShouldNotBeRegisteredWithServiceKey -> int
static readonly DryIoc.Error.DependencyHasShorterReuseLifespan -> int
static readonly DryIoc.Error.DisposerTrackForDisposeError -> int
static readonly DryIoc.Error.ExpectedSingleDefaultFactory -> int
static readonly DryIoc.Error.FoundNoRootsToValidate -> int
static readonly DryIoc.Error.GenericWrapperTypeArgIndexOutOfBounds -> int
static readonly DryIoc.Error.GenericWrapperWithMultipleTypeArgsShouldSpecifyArgIndex -> int
static readonly DryIoc.Error.GotNullConstructorFromFactoryMethod -> int
static readonly DryIoc.Error.GotNullFactoryWhenResolvingService -> int
static readonly DryIoc.Error.ImplTypeIsNotSpecifiedForAutoCtorSelection -> int
static readonly DryIoc.Error.InjectedCustomValueIsOfDifferentType -> int
static readonly DryIoc.Error.NoConversionOperatorFoundWhenInterpretingTheConvertExpression -> int
static readonly DryIoc.Error.NoCurrentScope -> int
static readonly DryIoc.Error.NoImplementationForPlaceholder -> int
static readonly DryIoc.Error.NoMatchedFactoryMethodDeclaringTypeWithServiceTypeArgs -> int
static readonly DryIoc.Error.NoMatchedFactoryMethodWithServiceTypeArgs -> int
static readonly DryIoc.Error.NoMatchedGenericParamConstraints -> int
static readonly DryIoc.Error.NoMatchedImplementedTypesWithServiceType -> int
static readonly DryIoc.Error.NoMatchedScopeFound -> int
static readonly DryIoc.Error.NoMoreRegistrationsAllowed -> int
static readonly DryIoc.Error.NoMoreUnregistrationsAllowed -> int
static readonly DryIoc.Error.NoServicesWereRegisteredByRegisterMany -> int
static readonly DryIoc.Error.NotFoundMetaCtorWithTwoArgs -> int
static readonly DryIoc.Error.NotFoundOpenGenericImplTypeArgInService -> int
static readonly DryIoc.Error.NotFoundSpecifiedWritablePropertyOrField -> int
static readonly DryIoc.Error.NotSupportedMadeOfExpression -> int
static readonly DryIoc.Error.OpenGenericFactoryMethodDeclaringTypeIsNotSupportedOnThisPlatform -> int
static readonly DryIoc.Error.PassedCtorOrMemberIsNull -> int
static readonly DryIoc.Error.PassedMemberIsNotStaticButInstanceFactoryIsNull -> int
static readonly DryIoc.Error.PassedMemberIsStaticButInstanceFactoryIsNotNull -> int
static readonly DryIoc.Error.PushingToRequestWithoutFactory -> int
static readonly DryIoc.Error.RecursiveDependencyDetected -> int
static readonly DryIoc.Error.RegisteredDelegateResultIsNotOfServiceType -> int
static readonly DryIoc.Error.RegisteredDisposableTransientWontBeDisposedByContainer -> int
static readonly DryIoc.Error.RegisteredFactoryMethodResultTypesIsNotAssignableToImplementationType -> int
static readonly DryIoc.Error.RegisteringAbstractImplementationTypeAndNoFactoryMethod -> int
static readonly DryIoc.Error.RegisteringImplementationNotAssignableToServiceType -> int
static readonly DryIoc.Error.RegisteringInstanceNotAssignableToServiceType -> int
static readonly DryIoc.Error.RegisteringNotAGenericTypedefImplType -> int
static readonly DryIoc.Error.RegisteringNotAGenericTypedefServiceType -> int
static readonly DryIoc.Error.RegisteringNullImplementationTypeAndNoFactoryMethod -> int
static readonly DryIoc.Error.RegisteringObjectTypeAsImplementationIsNotSupported -> int
static readonly DryIoc.Error.RegisteringOpenGenericImplWithNonGenericService -> int
static readonly DryIoc.Error.RegisteringOpenGenericRequiresFactoryProvider -> int
static readonly DryIoc.Error.RegisteringOpenGenericServiceWithMissingTypeArgs -> int
static readonly DryIoc.Error.RegisterMappingNotFoundRegisteredService -> int
static readonly DryIoc.Error.RegisterMappingUnableToSelectFromMultipleFactories -> int
static readonly DryIoc.Error.ResolutionNeedsRequiredServiceType -> int
static readonly DryIoc.Error.ResolvingOpenGenericServiceTypeIsNotPossible -> int
static readonly DryIoc.Error.ScopeIsDisposed -> int
static readonly DryIoc.Error.ServiceIsNotAssignableFromFactoryMethod -> int
static readonly DryIoc.Error.StateIsRequiredToUseItem -> int
static readonly DryIoc.Error.UnableToFindConstructorWithArgs -> int
static readonly DryIoc.Error.UnableToFindCtorWithAllResolvableArgs -> int
static readonly DryIoc.Error.UnableToFindSingleConstructor -> int
static readonly DryIoc.Error.UnableToFindSingletonInstance -> int
static readonly DryIoc.Error.UnableToInterpretTheNestedLambda -> int
static readonly DryIoc.Error.UnableToRegisterDuplicateDefault -> int
static readonly DryIoc.Error.UnableToRegisterDuplicateKey -> int
static readonly DryIoc.Error.UnableToResolveFromRegisteredServices -> int
static readonly DryIoc.Error.UnableToResolveUnknownService -> int
static readonly DryIoc.Error.UnableToSelectCtor -> int
static readonly DryIoc.Error.UnableToSelectFromManyRegistrationsWithMatchingMetadata -> int
static readonly DryIoc.Error.UnableToSelectSinglePublicConstructorFromMultiple -> int
static readonly DryIoc.Error.UnableToSelectSinglePublicConstructorFromNone -> int
static readonly DryIoc.Error.UndefinedFieldWhenGettingField -> int
static readonly DryIoc.Error.UndefinedMethodWhenGettingMethodWithSpecifiedParameters -> int
static readonly DryIoc.Error.UndefinedMethodWhenGettingTheSingleMethod -> int
static readonly DryIoc.Error.UndefinedPropertyWhenGettingProperty -> int
static readonly DryIoc.Error.UnexpectedExpressionInsteadOfArgMethodInMadeOf -> int
static readonly DryIoc.Error.UnexpectedExpressionInsteadOfConstantInMadeOf -> int
static readonly DryIoc.Error.UnexpectedFactoryMemberExpressionInMadeOf -> int
static readonly DryIoc.Error.WeakRefReuseWrapperGCed -> int
static readonly DryIoc.Messages.EmptyResponse.Value -> DryIoc.Messages.EmptyResponse
static readonly ImTools.Unit.unit -> ImTools.Unit
virtual DryIoc.Factory.CanAccessImplementationType.get -> bool
virtual DryIoc.Factory.HasRuntimeState.get -> bool
virtual DryIoc.Factory.RegistrationOrder.get -> int
virtual FastExpressionCompiler.LightExpression.MethodCallExpression.FewArgumentCount.get -> int
virtual FastExpressionCompiler.LightExpression.NewExpression.FewArgumentCount.get -> int
virtual ImTools.ImMap<V>.Height.get -> int
~abstract DryIoc.Factory.CreateExpressionOrDefault(DryIoc.Request request) -> FastExpressionCompiler.LightExpression.Expression
~abstract DryIoc.Messages.AsyncMessageHandler<M, R>.Handle(M message, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<R>
~abstract DryIoc.PropertyOrFieldServiceInfo.Create(System.Type serviceType, DryIoc.ServiceDetails details) -> DryIoc.IServiceInfo
~abstract DryIoc.PropertyOrFieldServiceInfo.Member.get -> System.Reflection.MemberInfo
~abstract DryIoc.PropertyOrFieldServiceInfo.ServiceType.get -> System.Type
~abstract DryIoc.PropertyOrFieldServiceInfo.SetValue(object holder, object value) -> void
~abstract FastExpressionCompiler.LightExpression.Expression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~abstract FastExpressionCompiler.LightExpression.Expression.Type.get -> System.Type
~abstract FastExpressionCompiler.LightExpression.MemberBinding.ToCodeString(System.Text.StringBuilder sb, int lineIdent, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~const DryIoc.ContainerTools.FacadeKey = "@facade" -> string
~DryIoc.AsyncExecutionFlowScopeContext.GetCurrentOrDefault() -> DryIoc.IScope
~DryIoc.AsyncExecutionFlowScopeContext.SetCurrent(DryIoc.SetCurrentScopeHandler changeCurrentScope) -> DryIoc.IScope
~DryIoc.CompositeScopeName.Match(object scopeName) -> bool
~DryIoc.Container.ClearCache(System.Type serviceType, DryIoc.FactoryType? factoryType, object serviceKey) -> bool
~DryIoc.Container.Container(DryIoc.Rules rules = null, DryIoc.IScopeContext scopeContext = null) -> void
~DryIoc.Container.Container(System.Func<DryIoc.Rules, DryIoc.Rules> configure, DryIoc.IScopeContext scopeContext = null) -> void
~DryIoc.Container.CurrentScope.get -> DryIoc.IScope
~DryIoc.Container.GetConstantExpression(object item, System.Type itemType = null, bool throwIfStateRequired = false) -> FastExpressionCompiler.LightExpression.Expression
~DryIoc.Container.GetRegisteredFactories(System.Type serviceType, object serviceKey, DryIoc.FactoryType factoryType) -> DryIoc.Factory[]
~DryIoc.Container.GetServiceRegistrations() -> System.Collections.Generic.IEnumerable<DryIoc.ServiceRegistrationInfo>
~DryIoc.Container.IsRegistered(System.Type serviceType, object serviceKey, DryIoc.FactoryType factoryType, System.Func<DryIoc.Factory, bool> condition) -> bool
~DryIoc.Container.OwnCurrentScope.get -> DryIoc.IScope
~DryIoc.Container.Parent.get -> DryIoc.IResolverContext
~DryIoc.Container.Register(DryIoc.Factory factory, System.Type serviceType, object serviceKey, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered, bool isStaticallyChecked) -> void
~DryIoc.Container.ResolveCompileTimeGeneratedOrDefault(System.Type serviceType) -> object
~DryIoc.Container.ResolveCompileTimeGeneratedOrDefault(System.Type serviceType, object serviceKey) -> object
~DryIoc.Container.ResolveManyCompileTimeGeneratedOrEmpty(System.Type serviceType) -> System.Collections.Generic.IEnumerable<DryIoc.Container.ResolveManyResult>
~DryIoc.Container.ResolveManyResult.FactoryDelegate -> DryIoc.FactoryDelegate
~DryIoc.Container.ResolveManyResult.RequiredServiceType -> System.Type
~DryIoc.Container.ResolveManyResult.ServiceKey -> object
~DryIoc.Container.Root.get -> DryIoc.IResolverContext
~DryIoc.Container.Rules.get -> DryIoc.Rules
~DryIoc.Container.ScopeContext.get -> DryIoc.IScopeContext
~DryIoc.Container.SingletonScope.get -> DryIoc.IScope
~DryIoc.Container.Unregister(System.Type serviceType, object serviceKey, DryIoc.FactoryType factoryType, System.Func<DryIoc.Factory, bool> condition) -> void
~DryIoc.Container.Use(System.Type serviceType, DryIoc.FactoryDelegate factory) -> void
~DryIoc.Container.UseInstance(System.Type serviceType, object instance, DryIoc.IfAlreadyRegistered ifAlreadyRegistered, bool preventDisposal, bool weaklyReferenced, object serviceKey) -> void
~DryIoc.Container.With(DryIoc.IResolverContext parent, DryIoc.Rules rules, DryIoc.IScopeContext scopeContext, DryIoc.RegistrySharing registrySharing, DryIoc.IScope singletonScope, DryIoc.IScope curentScope) -> DryIoc.IContainer
~DryIoc.Container.With(DryIoc.Rules rules, DryIoc.IScopeContext scopeContext, DryIoc.RegistrySharing registrySharing, DryIoc.IScope singletonScope) -> DryIoc.IContainer
~DryIoc.Container.WithCurrentScope(DryIoc.IScope scope) -> DryIoc.IResolverContext
~DryIoc.Container.WithNoMoreRegistrationAllowed(bool ignoreInsteadOfThrow = false) -> DryIoc.IContainer
~DryIoc.ContainerException.ContainerException(int error, string message) -> void
~DryIoc.ContainerException.ContainerException(int errorCode, string message, System.Exception innerException) -> void
~DryIoc.ContainerException.ContainerException(int errorCode, string message, System.Exception innerException, System.Func<int, string, System.Exception, string> formatMessage) -> void
~DryIoc.ContainerException.ContainerException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
~DryIoc.ContainerException.ErrorName.get -> string
~DryIoc.CurrentScopeReuse.Apply(DryIoc.Request request, FastExpressionCompiler.LightExpression.Expression serviceFactoryExpr) -> FastExpressionCompiler.LightExpression.Expression
~DryIoc.CurrentScopeReuse.CanApply(DryIoc.Request request) -> bool
~DryIoc.CurrentScopeReuse.CurrentScopeReuse(object name = null, bool scopedOrSingleton = false) -> void
~DryIoc.CurrentScopeReuse.CurrentScopeReuse(object name, bool scopedOrSingleton, int lifespan) -> void
~DryIoc.CurrentScopeReuse.Name.get -> object
~DryIoc.CurrentScopeReuse.ToExpression(System.Func<object, FastExpressionCompiler.LightExpression.Expression> fallbackConverter) -> FastExpressionCompiler.LightExpression.Expression
~DryIoc.DefaultDynamicKey.Next() -> DryIoc.DefaultDynamicKey
~DryIoc.DefaultDynamicKey.ToExpression(System.Func<object, FastExpressionCompiler.LightExpression.Expression> fallbackConverter) -> FastExpressionCompiler.LightExpression.Expression
~DryIoc.DefaultKey.Next() -> DryIoc.DefaultKey
~DryIoc.DefaultKey.ToExpression(System.Func<object, FastExpressionCompiler.LightExpression.Expression> fallbackConverter) -> FastExpressionCompiler.LightExpression.Expression
~DryIoc.DelegateFactory.DelegateFactory(DryIoc.FactoryDelegate factoryDelegate, DryIoc.IReuse reuse = null, DryIoc.Setup setup = null, System.Type knownImplementationType = null) -> void
~DryIoc.DynamicRegistration.DynamicRegistration(DryIoc.Factory factory, DryIoc.IfAlreadyRegistered ifAlreadyRegistered = DryIoc.IfAlreadyRegistered.AppendNotKeyed, object serviceKey = null) -> void
~DryIoc.ExpressionFactory.ExpressionFactory(System.Func<DryIoc.Request, FastExpressionCompiler.LightExpression.Expression> getServiceExpression, DryIoc.IReuse reuse = null, DryIoc.Setup setup = null) -> void
~DryIoc.Factory.CheckCondition(DryIoc.Request request) -> bool
~DryIoc.Factory.DoNotCache() -> DryIoc.Factory
~DryIoc.Factory.Factory(DryIoc.IReuse reuse = null, DryIoc.Setup setup = null) -> void
~DryIoc.FactoryMethod.FactoryMethod(System.Reflection.ConstructorInfo constructor) -> void
~DryIoc.HiddenDisposable.HiddenDisposable(object value) -> void
~DryIoc.IConcreteFactoryGenerator.GeneratedFactories.get -> ImTools.ImHashMap<ImTools.KV<System.Type, object>, DryIoc.ReflectionFactory>
~DryIoc.IConcreteFactoryGenerator.GetGeneratedFactory(DryIoc.Request request, bool ifErrorReturnDefault = false) -> DryIoc.Factory
~DryIoc.IContainer.ClearCache(System.Type serviceType, DryIoc.FactoryType? factoryType, object serviceKey) -> bool
~DryIoc.IContainer.GetAllServiceFactories(System.Type serviceType, bool bothClosedAndOpenGenerics = false) -> System.Collections.Generic.IEnumerable<ImTools.KV<object, DryIoc.Factory>>
~DryIoc.IContainer.GetConstantExpression(object item, System.Type itemType = null, bool throwIfStateRequired = false) -> FastExpressionCompiler.LightExpression.Expression
~DryIoc.IContainer.GetDecoratorExpressionOrDefault(DryIoc.Request request) -> FastExpressionCompiler.LightExpression.Expression
~DryIoc.IContainer.GetDecoratorFactoriesOrDefault(System.Type serviceType) -> DryIoc.Factory[]
~DryIoc.IContainer.GetServiceFactoryOrDefault(DryIoc.Request request) -> DryIoc.Factory
~DryIoc.IContainer.GetWrappedType(System.Type serviceType, System.Type requiredServiceType) -> System.Type
~DryIoc.IContainer.GetWrapperFactoryOrDefault(System.Type serviceType) -> DryIoc.Factory
~DryIoc.IContainer.OwnCurrentScope.get -> DryIoc.IScope
~DryIoc.IContainer.ResolveFactory(DryIoc.Request request) -> DryIoc.Factory
~DryIoc.IContainer.Rules.get -> DryIoc.Rules
~DryIoc.IContainer.Use(System.Type serviceType, DryIoc.FactoryDelegate factory) -> void
~DryIoc.IContainer.UseInstance(System.Type serviceType, object instance, DryIoc.IfAlreadyRegistered IfAlreadyRegistered, bool preventDisposal, bool weaklyReferenced, object serviceKey) -> void
~DryIoc.IContainer.With(DryIoc.IResolverContext parent, DryIoc.Rules rules, DryIoc.IScopeContext scopeContext, DryIoc.RegistrySharing registrySharing, DryIoc.IScope singletonScope, DryIoc.IScope currentScope) -> DryIoc.IContainer
~DryIoc.IContainer.With(DryIoc.Rules rules, DryIoc.IScopeContext scopeContext, DryIoc.RegistrySharing registrySharing, DryIoc.IScope singletonScope) -> DryIoc.IContainer
~DryIoc.IContainer.WithNoMoreRegistrationAllowed(bool ignoreInsteadOfThrow = false) -> DryIoc.IContainer
~DryIoc.IConvertibleToExpression.ToExpression(System.Func<object, FastExpressionCompiler.LightExpression.Expression> fallbackConverter) -> FastExpressionCompiler.LightExpression.Expression
~DryIoc.Interpreter.ParentLambdaArgs.ParentLambdaArgs(DryIoc.Interpreter.ParentLambdaArgs parentWithArgs, object paramExprs, object paramValues) -> void
~DryIoc.IRegistrator.GetRegisteredFactories(System.Type serviceType, object serviceKey, DryIoc.FactoryType factoryType) -> DryIoc.Factory[]
~DryIoc.IRegistrator.GetServiceRegistrations() -> System.Collections.Generic.IEnumerable<DryIoc.ServiceRegistrationInfo>
~DryIoc.IRegistrator.IsRegistered(System.Type serviceType, object serviceKey, DryIoc.FactoryType factoryType, System.Func<DryIoc.Factory, bool> condition) -> bool
~DryIoc.IRegistrator.Register(DryIoc.Factory factory, System.Type serviceType, object serviceKey, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered, bool isStaticallyChecked) -> void
~DryIoc.IRegistrator.Unregister(System.Type serviceType, object serviceKey, DryIoc.FactoryType factoryType, System.Func<DryIoc.Factory, bool> condition) -> void
~DryIoc.IRegistrator.Use(System.Type serviceType, DryIoc.FactoryDelegate factory) -> void
~DryIoc.IRegistrator.UseInstance(System.Type serviceType, object instance, DryIoc.IfAlreadyRegistered IfAlreadyRegistered, bool preventDisposal, bool weaklyReferenced, object serviceKey) -> void
~DryIoc.IResolver.Resolve(System.Type serviceType, DryIoc.IfUnresolved ifUnresolved) -> object
~DryIoc.IResolver.Resolve(System.Type serviceType, object serviceKey, DryIoc.IfUnresolved ifUnresolved, System.Type requiredServiceType, DryIoc.Request preResolveParent, object[] args) -> object
~DryIoc.IResolver.ResolveMany(System.Type serviceType, object serviceKey, System.Type requiredServiceType, DryIoc.Request preResolveParent, object[] args) -> System.Collections.Generic.IEnumerable<object>
~DryIoc.IResolverContext.CurrentScope.get -> DryIoc.IScope
~DryIoc.IResolverContext.InjectPropertiesAndFields(object instance, string[] propertyAndFieldNames) -> void
~DryIoc.IResolverContext.Parent.get -> DryIoc.IResolverContext
~DryIoc.IResolverContext.Root.get -> DryIoc.IResolverContext
~DryIoc.IResolverContext.ScopeContext.get -> DryIoc.IScopeContext
~DryIoc.IResolverContext.SingletonScope.get -> DryIoc.IScope
~DryIoc.IResolverContext.Use(System.Type serviceType, DryIoc.FactoryDelegate factory) -> void
~DryIoc.IResolverContext.UseInstance(System.Type serviceType, object instance, DryIoc.IfAlreadyRegistered IfAlreadyRegistered, bool preventDisposal, bool weaklyReferenced, object serviceKey) -> void
~DryIoc.IResolverContext.WithCurrentScope(DryIoc.IScope scope) -> DryIoc.IResolverContext
~DryIoc.IReuse.Apply(DryIoc.Request request, FastExpressionCompiler.LightExpression.Expression serviceFactoryExpr) -> FastExpressionCompiler.LightExpression.Expression
~DryIoc.IReuse.CanApply(DryIoc.Request request) -> bool
~DryIoc.IReuse.Name.get -> object
~DryIoc.IScope.Clone() -> DryIoc.IScope
~DryIoc.IScope.GetOrAdd(int id, DryIoc.CreateScopedValue createValue, int disposalOrder = 0) -> object
~DryIoc.IScope.GetOrAddViaFactoryDelegate(int id, DryIoc.FactoryDelegate createValue, DryIoc.IResolverContext r, int disposalOrder = 0) -> object
~DryIoc.IScope.GetOrTryAdd(int id, object item, int disposalOrder) -> object
~DryIoc.IScope.Name.get -> object
~DryIoc.IScope.Parent.get -> DryIoc.IScope
~DryIoc.IScope.SetOrAdd(int id, object item) -> void
~DryIoc.IScope.SetUsedInstance(int typeHash, System.Type type, DryIoc.FactoryDelegate factory) -> void
~DryIoc.IScope.SetUsedInstance(System.Type type, DryIoc.FactoryDelegate factory) -> void
~DryIoc.IScope.TrackDisposable(object item, int disposalOrder = 0) -> object
~DryIoc.IScope.TrackDisposableWithoutDisposalOrder<T>(T disposable) -> T
~DryIoc.IScope.TryGet(out object item, int id) -> bool
~DryIoc.IScope.TryGetOrAddWithoutClosure(int id, DryIoc.IResolverContext resolveContext, FastExpressionCompiler.LightExpression.Expression expr, bool useFec, System.Func<DryIoc.IResolverContext, FastExpressionCompiler.LightExpression.Expression, bool, object> createValue, int disposalOrder = 0) -> object
~DryIoc.IScope.TryGetUsedInstance(DryIoc.IResolverContext r, System.Type type, out object instance) -> bool
~DryIoc.IScopeContext.GetCurrentOrDefault() -> DryIoc.IScope
~DryIoc.IScopeContext.SetCurrent(DryIoc.SetCurrentScopeHandler setCurrentScope) -> DryIoc.IScope
~DryIoc.IScopeName.Match(object scopeName) -> bool
~DryIoc.IServiceInfo.Create(System.Type serviceType, DryIoc.ServiceDetails details) -> DryIoc.IServiceInfo
~DryIoc.IServiceInfo.Details.get -> DryIoc.ServiceDetails
~DryIoc.IServiceInfo.ServiceType.get -> System.Type
~DryIoc.LazyEnumerable<TService>.GetEnumerator() -> System.Collections.Generic.IEnumerator<TService>
~DryIoc.LazyEnumerable<TService>.LazyEnumerable(System.Collections.Generic.IEnumerable<TService> items) -> void
~DryIoc.Made.FactoryMethod.get -> DryIoc.FactoryMethodSelector
~DryIoc.Made.FactoryMethodKnownResultType.get -> System.Type
~DryIoc.Made.Parameters.get -> DryIoc.ParameterSelector
~DryIoc.Made.PropertiesAndFields.get -> DryIoc.PropertiesAndFieldsSelector
~DryIoc.Messages.AsyncMessageHandler<M, R>
~DryIoc.Messages.BroadcastMessageHandler<M>
~DryIoc.Messages.BroadcastMessageHandler<M>.BroadcastMessageHandler(System.Collections.Generic.IEnumerable<DryIoc.Messages.IMessageHandler<M, DryIoc.Messages.EmptyResponse>> handlers) -> void
~DryIoc.Messages.BroadcastMessageHandler<M>.Handle(M message, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<DryIoc.Messages.EmptyResponse>
~DryIoc.Messages.IMessageHandler<M, R>
~DryIoc.Messages.IMessageHandler<M, R>.Handle(M message, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<R>
~DryIoc.Messages.IMessageHandler<M>
~DryIoc.Messages.IMessageMiddleware<M, R>.Handle(M message, System.Threading.CancellationToken cancellationToken, System.Func<System.Threading.Tasks.Task<R>> nextMiddleware) -> System.Threading.Tasks.Task<R>
~DryIoc.Messages.MessageMediator.MessageMediator(DryIoc.IResolver resolver) -> void
~DryIoc.Messages.MessageMediator.Send<M, R>(M message, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<R>
~DryIoc.Messages.MessageMediator.Send<M>(M message, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
~DryIoc.Messages.MiddlewareMessageHandler<M, R>
~DryIoc.Messages.MiddlewareMessageHandler<M, R>.Handle(M message, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<R>
~DryIoc.Messages.MiddlewareMessageHandler<M, R>.MiddlewareMessageHandler(DryIoc.Messages.IMessageHandler<M, R> handler, System.Collections.Generic.IEnumerable<DryIoc.Messages.IMessageMiddleware<M, R>> middlewares) -> void
~DryIoc.OpenGenericTypeKey.OpenGenericTypeKey(System.Type requiredServiceType, object serviceKey) -> void
~DryIoc.OpenGenericTypeKey.ToExpression(System.Func<object, FastExpressionCompiler.LightExpression.Expression> fallbackConverter) -> FastExpressionCompiler.LightExpression.Expression
~DryIoc.ParameterServiceInfo.Create(System.Type serviceType, DryIoc.ServiceDetails details) -> DryIoc.IServiceInfo
~DryIoc.ReflectionFactory.ReflectionFactory(System.Func<System.Type> implementationTypeProvider, DryIoc.IReuse reuse = null, DryIoc.Made made = null, DryIoc.Setup setup = null) -> void
~DryIoc.ReflectionFactory.ReflectionFactory(System.Type implementationType = null, DryIoc.IReuse reuse = null, DryIoc.Made made = null, DryIoc.Setup setup = null) -> void
~DryIoc.RegisteredInstanceFactory.RegisteredInstanceFactory(object instance, DryIoc.IReuse reuse = null, DryIoc.Setup setup = null) -> void
~DryIoc.Request.ChangeServiceKey(object serviceKey) -> void
~DryIoc.Request.Container -> DryIoc.IContainer
~DryIoc.Request.CurrentScope.get -> DryIoc.IScope
~DryIoc.Request.DirectParent -> DryIoc.Request
~DryIoc.Request.Enumerate() -> System.Collections.Generic.IEnumerable<DryIoc.Request>
~DryIoc.Request.Equals(DryIoc.Request other) -> bool
~DryIoc.Request.EqualsWithoutParent(DryIoc.Request other) -> bool
~DryIoc.Request.GetActualServiceType() -> System.Type
~DryIoc.Request.GetEnumerator() -> System.Collections.Generic.IEnumerator<DryIoc.Request>
~DryIoc.Request.GetInputArgsExpr() -> FastExpressionCompiler.LightExpression.Expression
~DryIoc.Request.GetKnownImplementationOrServiceType() -> System.Type
~DryIoc.Request.ImplementationType.get -> System.Type
~DryIoc.Request.Is<TResult>(System.Func<TResult> root = null, System.Func<System.Reflection.ParameterInfo, TResult> parameter = null, System.Func<System.Reflection.PropertyInfo, TResult> property = null, System.Func<System.Reflection.FieldInfo, TResult> field = null) -> TResult
~DryIoc.Request.Made.get -> DryIoc.Made
~DryIoc.Request.Metadata.get -> object
~DryIoc.Request.MetadataKey.get -> string
~DryIoc.Request.Parent.get -> DryIoc.Request
~DryIoc.Request.Print(int recursiveFactoryID = 0) -> System.Text.StringBuilder
~DryIoc.Request.PrintCurrent(System.Text.StringBuilder s = null) -> System.Text.StringBuilder
~DryIoc.Request.Push(DryIoc.IServiceInfo info, DryIoc.RequestFlags additionalFlags = (DryIoc.RequestFlags)0) -> DryIoc.Request
~DryIoc.Request.Push(System.Type serviceType, int factoryID, System.Type implementationType, DryIoc.IReuse reuse) -> DryIoc.Request
~DryIoc.Request.Push(System.Type serviceType, object serviceKey = null, DryIoc.IfUnresolved ifUnresolved = DryIoc.IfUnresolved.Throw, System.Type requiredServiceType = null, DryIoc.RequestFlags flags = (DryIoc.RequestFlags)0) -> DryIoc.Request
~DryIoc.Request.Push(System.Type serviceType, System.Type requiredServiceType, object serviceKey, DryIoc.IfUnresolved ifUnresolved, int factoryID, DryIoc.FactoryType factoryType, System.Type implementationType, DryIoc.IReuse reuse, DryIoc.RequestFlags flags, int decoratedFactoryID) -> DryIoc.Request
~DryIoc.Request.Push(System.Type serviceType, System.Type requiredServiceType, object serviceKey, int factoryID, DryIoc.FactoryType factoryType, System.Type implementationType, DryIoc.IReuse reuse, DryIoc.RequestFlags flags) -> DryIoc.Request
~DryIoc.Request.Push(System.Type serviceType, System.Type requiredServiceType, object serviceKey, string metadataKey, object metadata, DryIoc.IfUnresolved ifUnresolved, int factoryID, DryIoc.FactoryType factoryType, System.Type implementationType, DryIoc.IReuse reuse, DryIoc.RequestFlags flags, int decoratedFactoryID) -> DryIoc.Request
~DryIoc.Request.RequiredServiceType.get -> System.Type
~DryIoc.Request.Reuse.get -> DryIoc.IReuse
~DryIoc.Request.Rules.get -> DryIoc.Rules
~DryIoc.Request.ServiceKey.get -> object
~DryIoc.Request.ServiceType.get -> System.Type
~DryIoc.Request.SingletonScope.get -> DryIoc.IScope
~DryIoc.Request.WithChangedServiceInfo(System.Func<DryIoc.IServiceInfo, DryIoc.IServiceInfo> getInfo) -> DryIoc.Request
~DryIoc.Request.WithFlags(DryIoc.RequestFlags newFlags) -> DryIoc.Request
~DryIoc.Request.WithIfUnresolved(DryIoc.IfUnresolved ifUnresolved) -> DryIoc.Request
~DryIoc.Request.WithInputArgs(FastExpressionCompiler.LightExpression.Expression[] inputArgs) -> DryIoc.Request
~DryIoc.Request.WithResolvedFactory(DryIoc.Factory factory, bool skipRecursiveDependencyCheck = false, bool skipCaptiveDependencyCheck = false, bool copyRequest = false) -> DryIoc.Request
~DryIoc.ResolutionScopeName.Match(object scopeName) -> bool
~DryIoc.Rules.DefaultRegistrationServiceKey.get -> object
~DryIoc.Rules.DefaultReuse.get -> DryIoc.IReuse
~DryIoc.Rules.DependencyResolutionCallExprs.get -> ImTools.Ref<ImTools.ImHashMap<DryIoc.Request, System.Linq.Expressions.Expression>>
~DryIoc.Rules.DynamicRegistrationProviders.get -> DryIoc.Rules.DynamicRegistrationProvider[]
~DryIoc.Rules.FactoryMethod.get -> DryIoc.FactoryMethodSelector
~DryIoc.Rules.FactorySelector.get -> DryIoc.Rules.FactorySelectorRule
~DryIoc.Rules.ForExpressionGeneration(bool allowRuntimeState = false) -> DryIoc.Rules
~DryIoc.Rules.ForValidate() -> DryIoc.Rules
~DryIoc.Rules.ItemToExpressionConverter.get -> DryIoc.Rules.ItemToExpressionConverterRule
~DryIoc.Rules.Parameters.get -> DryIoc.ParameterSelector
~DryIoc.Rules.PropertiesAndFields.get -> DryIoc.PropertiesAndFieldsSelector
~DryIoc.Rules.TryGetParameterSelector(DryIoc.Made made) -> DryIoc.ParameterSelector
~DryIoc.Rules.TryGetPropertiesAndFieldsSelector(DryIoc.Made made) -> DryIoc.PropertiesAndFieldsSelector
~DryIoc.Rules.UnknownServiceResolvers.get -> DryIoc.Rules.UnknownServiceResolver[]
~DryIoc.Rules.With(DryIoc.FactoryMethodSelector factoryMethod = null, DryIoc.ParameterSelector parameters = null, DryIoc.PropertiesAndFieldsSelector propertiesAndFields = null) -> DryIoc.Rules
~DryIoc.Rules.With(DryIoc.Made made, bool overrideRegistrationMade = false) -> DryIoc.Rules
~DryIoc.Rules.WithAutoConcreteTypeResolution(System.Func<DryIoc.Request, bool> condition = null) -> DryIoc.Rules
~DryIoc.Rules.WithCaptureContainerDisposeStackTrace() -> DryIoc.Rules
~DryIoc.Rules.WithConcreteTypeDynamicRegistrations(System.Func<System.Type, object, bool> condition = null, DryIoc.IReuse reuse = null) -> DryIoc.Rules
~DryIoc.Rules.WithDefaultIfAlreadyRegistered(DryIoc.IfAlreadyRegistered rule) -> DryIoc.Rules
~DryIoc.Rules.WithDefaultRegistrationServiceKey(object serviceKey) -> DryIoc.Rules
~DryIoc.Rules.WithDefaultReuse(DryIoc.IReuse reuse) -> DryIoc.Rules
~DryIoc.Rules.WithDefaultReuseInsteadOfTransient(DryIoc.IReuse reuse) -> DryIoc.Rules
~DryIoc.Rules.WithDependencyCountInLambdaToSplitBigObjectGraph(int dependencyCount) -> DryIoc.Rules
~DryIoc.Rules.WithDependencyDepthToSplitObjectGraph(int depth) -> DryIoc.Rules
~DryIoc.Rules.WithDynamicRegistrations(params DryIoc.Rules.DynamicRegistrationProvider[] rules) -> DryIoc.Rules
~DryIoc.Rules.WithDynamicRegistrationsAsFallback(params DryIoc.Rules.DynamicRegistrationProvider[] rules) -> DryIoc.Rules
~DryIoc.Rules.WithExpressionGeneration(bool allowRuntimeState = false) -> DryIoc.Rules
~DryIoc.Rules.WithFactorySelector(DryIoc.Rules.FactorySelectorRule rule) -> DryIoc.Rules
~DryIoc.Rules.WithFuncAndLazyWithoutRegistration() -> DryIoc.Rules
~DryIoc.Rules.WithIgnoringReuseForFuncWithArgs() -> DryIoc.Rules
~DryIoc.Rules.WithItemToExpressionConverter(DryIoc.Rules.ItemToExpressionConverterRule itemToExpressionOrDefault) -> DryIoc.Rules
~DryIoc.Rules.WithMicrosoftDependencyInjectionRules() -> DryIoc.Rules
~DryIoc.Rules.WithoutDependencyCountInLambdaToSplitBigObjectGraph() -> DryIoc.Rules
~DryIoc.Rules.WithoutDependencyDepthToSplitObjectGraph() -> DryIoc.Rules
~DryIoc.Rules.WithoutEagerCachingSingletonForFasterAccess() -> DryIoc.Rules
~DryIoc.Rules.WithoutFastExpressionCompiler() -> DryIoc.Rules
~DryIoc.Rules.WithoutImplicitCheckForReuseMatchingScope() -> DryIoc.Rules
~DryIoc.Rules.WithoutInterpretationForTheFirstResolution() -> DryIoc.Rules
~DryIoc.Rules.WithoutThrowIfDependencyHasShorterReuseLifespan() -> DryIoc.Rules
~DryIoc.Rules.WithoutThrowOnRegisteringDisposableTransient() -> DryIoc.Rules
~DryIoc.Rules.WithoutUnknownServiceResolver(DryIoc.Rules.UnknownServiceResolver rule) -> DryIoc.Rules
~DryIoc.Rules.WithoutUseInterpretation() -> DryIoc.Rules
~DryIoc.Rules.WithoutVariantGenericTypesInResolvedCollection() -> DryIoc.Rules
~DryIoc.Rules.WithResolveIEnumerableAsLazyEnumerable() -> DryIoc.Rules
~DryIoc.Rules.WithThrowIfRuntimeStateRequired() -> DryIoc.Rules
~DryIoc.Rules.WithTrackingDisposableTransients() -> DryIoc.Rules
~DryIoc.Rules.WithUnknownServiceHandler(System.Action<DryIoc.Request> handler) -> DryIoc.Rules
~DryIoc.Rules.WithUnknownServiceResolvers(params DryIoc.Rules.UnknownServiceResolver[] rules) -> DryIoc.Rules
~DryIoc.Rules.WithUseDecorateeReuseForDecorators() -> DryIoc.Rules
~DryIoc.Rules.WithUseInterpretation() -> DryIoc.Rules
~DryIoc.Scope.Clone() -> DryIoc.IScope
~DryIoc.Scope.GetEnumerator() -> System.Collections.Generic.IEnumerator<DryIoc.IScope>
~DryIoc.Scope.GetOrAdd(int id, DryIoc.CreateScopedValue createValue, int disposalOrder = 0) -> object
~DryIoc.Scope.GetOrAddViaFactoryDelegate(int id, DryIoc.FactoryDelegate createValue, DryIoc.IResolverContext r, int disposalOrder = 0) -> object
~DryIoc.Scope.GetOrTryAdd(int id, object newItem, int disposalOrder) -> object
~DryIoc.Scope.Name.get -> object
~DryIoc.Scope.Parent.get -> DryIoc.IScope
~DryIoc.Scope.Scope(DryIoc.IScope parent = null, object name = null) -> void
~DryIoc.Scope.SetOrAdd(int id, object item) -> void
~DryIoc.Scope.SetUsedInstance(int typeHash, System.Type type, DryIoc.FactoryDelegate factory) -> void
~DryIoc.Scope.SetUsedInstance(System.Type type, DryIoc.FactoryDelegate factory) -> void
~DryIoc.Scope.TrackDisposable(object item, int disposalOrder = 0) -> object
~DryIoc.Scope.TrackDisposableWithoutDisposalOrder<T>(T disposable) -> T
~DryIoc.Scope.TryGet(out object item, int id) -> bool
~DryIoc.Scope.TryGetOrAddWithoutClosure(int id, DryIoc.IResolverContext resolveContext, FastExpressionCompiler.LightExpression.Expression expr, bool useFec, System.Func<DryIoc.IResolverContext, FastExpressionCompiler.LightExpression.Expression, bool, object> createValue, int disposalOrder = 0) -> object
~DryIoc.Scope.TryGetUsedInstance(DryIoc.IResolverContext r, System.Type type, out object instance) -> bool
~DryIoc.ServiceDetails.CustomValue.get -> object
~DryIoc.ServiceDetails.DefaultValue.get -> object
~DryIoc.ServiceInfo.Create(System.Type serviceType, DryIoc.ServiceDetails details) -> DryIoc.IServiceInfo
~DryIoc.ServiceInfo.ServiceKey.get -> object
~DryIoc.ServiceInfo.ServiceType.get -> System.Type
~DryIoc.ServiceRegistrationInfo.Factory -> DryIoc.Factory
~DryIoc.ServiceRegistrationInfo.ImplementationType.get -> System.Type
~DryIoc.ServiceRegistrationInfo.OptionalServiceKey -> object
~DryIoc.ServiceRegistrationInfo.ServiceRegistrationInfo(DryIoc.Factory factory, System.Type serviceType, object optionalServiceKey) -> void
~DryIoc.ServiceRegistrationInfo.ServiceType -> System.Type
~DryIoc.ServiceRegistrationInfo.ToServiceInfo() -> DryIoc.ServiceInfo
~DryIoc.ServiceRegistrationInfo.ToServiceInfo(System.Type serviceType) -> DryIoc.ServiceInfo
~DryIoc.ServiceRegistrationInfo.ToServiceInfo<TService>() -> DryIoc.ServiceInfo
~DryIoc.Setup.Condition.get -> System.Func<DryIoc.Request, bool>
~DryIoc.Setup.MatchesMetadata(string metadataKey, object metadata) -> bool
~DryIoc.SingletonReuse.Apply(DryIoc.Request request, FastExpressionCompiler.LightExpression.Expression serviceFactoryExpr) -> FastExpressionCompiler.LightExpression.Expression
~DryIoc.SingletonReuse.CanApply(DryIoc.Request request) -> bool
~DryIoc.SingletonReuse.Name.get -> object
~DryIoc.SingletonReuse.ToExpression(System.Func<object, FastExpressionCompiler.LightExpression.Expression> fallbackConverter) -> FastExpressionCompiler.LightExpression.Expression
~DryIoc.ThreadScopeContext.GetCurrentOrDefault() -> DryIoc.IScope
~DryIoc.ThreadScopeContext.SetCurrent(DryIoc.SetCurrentScopeHandler setCurrentScope) -> DryIoc.IScope
~FastExpressionCompiler.LightExpression.ArgumentsExpression.ArgumentsExpression(System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.Expression> arguments) -> void
~FastExpressionCompiler.LightExpression.BinaryExpression.BinaryExpression(System.Linq.Expressions.ExpressionType nodeType, FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right, System.Type type) -> void
~FastExpressionCompiler.LightExpression.BlockExpression.Result.get -> FastExpressionCompiler.LightExpression.Expression
~FastExpressionCompiler.LightExpression.CodePrinter.IObjectToCode.ToCode(object x, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null) -> string
~FastExpressionCompiler.LightExpression.ConvertWithMethodUnaryExpression.ConvertWithMethodUnaryExpression(System.Linq.Expressions.ExpressionType nodeType, FastExpressionCompiler.LightExpression.Expression operand, System.Reflection.MethodInfo method) -> void
~FastExpressionCompiler.LightExpression.ConvertWithMethodUnaryExpression.ConvertWithMethodUnaryExpression(System.Linq.Expressions.ExpressionType nodeType, FastExpressionCompiler.LightExpression.Expression operand, System.Type type, System.Reflection.MethodInfo method) -> void
~FastExpressionCompiler.LightExpression.Expression.CodeString.get -> string
~FastExpressionCompiler.LightExpression.Expression.ToExpression() -> System.Linq.Expressions.Expression
~FastExpressionCompiler.LightExpression.Expression<TDelegate>.ToLambdaExpression() -> System.Linq.Expressions.Expression<TDelegate>
~FastExpressionCompiler.LightExpression.ExpressionCompiler.ArrayClosure.ArrayClosure(object[] constantsAndNestedLambdas) -> void
~FastExpressionCompiler.LightExpression.ExpressionCompiler.ArrayClosureWithNonPassedParams.ArrayClosureWithNonPassedParams(object[] constantsAndNestedLambdas, object[] nonPassedParams) -> void
~FastExpressionCompiler.LightExpression.ExpressionCompiler.NestedLambdaWithConstantsAndNestedLambdas.NestedLambdaWithConstantsAndNestedLambdas(object nestedLambda, object constantsAndNestedLambdas) -> void
~FastExpressionCompiler.LightExpression.FieldExpression.FieldInfo.get -> System.Reflection.FieldInfo
~FastExpressionCompiler.LightExpression.LambdaExpression.ToLambdaExpression() -> System.Linq.Expressions.LambdaExpression
~FastExpressionCompiler.LightExpression.MemberBinding.CodeString.get -> string
~FastExpressionCompiler.LightExpression.MemberExpression.MemberExpression(FastExpressionCompiler.LightExpression.Expression expression, System.Reflection.MemberInfo member) -> void
~FastExpressionCompiler.LightExpression.MemberInitExpression.NewExpression.get -> FastExpressionCompiler.LightExpression.NewExpression
~FastExpressionCompiler.LightExpression.NewArrayExpression.Expressions.get -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.Expression>
~FastExpressionCompiler.LightExpression.OneVariableTwoExpressionBlockExpression.Result.get -> FastExpressionCompiler.LightExpression.Expression
~FastExpressionCompiler.LightExpression.PropertyExpression.PropertyInfo.get -> System.Reflection.PropertyInfo
~FastExpressionCompiler.LightExpression.SwitchCase.SwitchCase(FastExpressionCompiler.LightExpression.Expression body, System.Collections.Generic.IEnumerable<FastExpressionCompiler.LightExpression.Expression> testValues) -> void
~FastExpressionCompiler.LightExpression.SwitchExpression.Cases.get -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.SwitchCase>
~FastExpressionCompiler.LightExpression.SwitchExpression.SwitchExpression(System.Type type, FastExpressionCompiler.LightExpression.Expression switchValue, FastExpressionCompiler.LightExpression.Expression defaultBody, System.Reflection.MethodInfo comparison, FastExpressionCompiler.LightExpression.SwitchCase[] cases) -> void
~FastExpressionCompiler.LightExpression.TryExpression.Handlers.get -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.CatchBlock>
~FastExpressionCompiler.LightExpression.TypeBinaryExpression.TypeOperand.get -> System.Type
~FastExpressionCompiler.LightExpression.TypedUnaryExpression.TypedUnaryExpression(System.Linq.Expressions.ExpressionType nodeType, FastExpressionCompiler.LightExpression.Expression operand, System.Type type) -> void
~FastExpressionCompiler.LightExpression.TypedUnaryExpression<T>.TypedUnaryExpression(System.Linq.Expressions.ExpressionType nodeType, FastExpressionCompiler.LightExpression.Expression operand) -> void
~FastExpressionCompiler.LightExpression.UnaryExpression.UnaryExpression(System.Linq.Expressions.ExpressionType nodeType, FastExpressionCompiler.LightExpression.Expression operand) -> void
~ImTools.Box<TBox, T>
~ImTools.Box<TBox, T>.Equals(ImTools.Box<TBox, T> other) -> bool
~ImTools.GrowingList<T>.GrowingList(T[] items, int count = 0) -> void
~ImTools.GrowingList<T>.Items -> T[]
~ImTools.ImHashMap<K, V>.AddOrKeep(int hash, K key) -> ImTools.ImHashMap<K, V>
~ImTools.ImHashMap<K, V>.AddOrKeep(int hash, K key, V value) -> ImTools.ImHashMap<K, V>
~ImTools.ImHashMap<K, V>.AddOrKeep(K key) -> ImTools.ImHashMap<K, V>
~ImTools.ImHashMap<K, V>.AddOrKeep(K key, V value) -> ImTools.ImHashMap<K, V>
~ImTools.ImHashMap<K, V>.AddOrUpdate(int hash, K key, V value) -> ImTools.ImHashMap<K, V>
~ImTools.ImHashMap<K, V>.AddOrUpdate(int hash, K key, V value, ImTools.Update<K, V> update) -> ImTools.ImHashMap<K, V>
~ImTools.ImHashMap<K, V>.AddOrUpdate(K key, V value) -> ImTools.ImHashMap<K, V>
~ImTools.ImHashMap<K, V>.AddOrUpdate(K key, V value, ImTools.Update<K, V> update) -> ImTools.ImHashMap<K, V>
~ImTools.ImHashMap<K, V>.AddOrUpdate(K key, V value, ImTools.Update<V> update) -> ImTools.ImHashMap<K, V>
~ImTools.ImHashMap<K, V>.Conflicts.get -> ImTools.ImHashMapEntry<K, V>[]
~ImTools.ImHashMap<K, V>.Enumerate() -> System.Collections.Generic.IEnumerable<ImTools.ImHashMapEntry<K, V>>
~ImTools.ImHashMap<K, V>.FindFirstOrDefault(System.Func<ImTools.ImHashMapEntry<K, V>, bool> condition, ImTools.ImHashMap<K, V>[] parentsStack = null) -> ImTools.ImHashMapEntry<K, V>
~ImTools.ImHashMap<K, V>.Fold<S>(S state, System.Func<ImTools.ImHashMapEntry<K, V>, int, S, S> reduce, ImTools.ImHashMap<K, V>[] parentsStack = null) -> S
~ImTools.ImHashMap<K, V>.Fold<S>(S state, System.Func<ImTools.ImHashMapEntry<K, V>, S, S> reduce, ImTools.ImHashMap<K, V>[] parentsStack = null) -> S
~ImTools.ImHashMap<K, V>.GetConflictedEntryOrDefault(K key) -> ImTools.ImHashMapEntry<K, V>
~ImTools.ImHashMap<K, V>.ImHashMap(ImTools.ImHashMapEntry<K, V> entry) -> void
~ImTools.ImHashMap<K, V>.ImHashMap(ImTools.ImHashMapEntry<K, V> entry, ImTools.ImHashMap<K, V> left, ImTools.ImHashMap<K, V> right) -> void
~ImTools.ImHashMap<K, V>.ImHashMap(ImTools.ImHashMapEntry<K, V> entry, ImTools.ImHashMap<K, V> left, ImTools.ImHashMap<K, V> right, int height) -> void
~ImTools.ImHashMap<K, V>.Left -> ImTools.ImHashMap<K, V>
~ImTools.ImHashMap<K, V>.Remove(int hash, K key) -> ImTools.ImHashMap<K, V>
~ImTools.ImHashMap<K, V>.Remove(K key) -> ImTools.ImHashMap<K, V>
~ImTools.ImHashMap<K, V>.Right -> ImTools.ImHashMap<K, V>
~ImTools.ImHashMap<K, V>.Update(int hash, K key, V value, ImTools.Update<K, V> update = null) -> ImTools.ImHashMap<K, V>
~ImTools.ImHashMap<K, V>.Update(K key, V value) -> ImTools.ImHashMap<K, V>
~ImTools.ImHashMap<K, V>.Update(K key, V value, ImTools.Update<V> update) -> ImTools.ImHashMap<K, V>
~ImTools.ImHashMap<K, V>.UpdateToDefault(int hash, K key) -> ImTools.ImHashMap<K, V>
~ImTools.ImHashMap<K, V>.Visit(System.Action<ImTools.ImHashMapEntry<K, V>> effect, ImTools.ImHashMap<K, V>[] parentsStack = null) -> void
~ImTools.ImHashMap<K, V>.Visit<S>(S state, System.Action<ImTools.ImHashMapEntry<K, V>, S> effect, ImTools.ImHashMap<K, V>[] parentsStack = null) -> S
~ImTools.ImHashMapConflicts<K, V>.ImHashMapConflicts(int hash, params ImTools.ImHashMapEntry<K, V>[] conflicts) -> void
~ImTools.ImList<T>.Enumerate() -> System.Collections.Generic.IEnumerable<T>
~ImTools.ImList<T>.Push(T head) -> ImTools.ImList<T>
~ImTools.ImMap.KValue<K>.KValue(K key, object value) -> void
~ImTools.ImMap.KValue<K>.Value -> object
~ImTools.ImMapBranch<V>.ImMapBranch(ImTools.ImMapEntry<V> entry, ImTools.ImMapEntry<V> rightEntry) -> void
~ImTools.ImMapBranch<V>.RightEntry -> ImTools.ImMapEntry<V>
~ImTools.ImMapTree<V>.AddOrKeepLeftOrRight(int key) -> ImTools.ImMapTree<V>
~ImTools.ImMapTree<V>.AddOrKeepLeftOrRight(int key, V value) -> ImTools.ImMapTree<V>
~ImTools.ImMapTree<V>.AddOrKeepLeftOrRightEntry(int key, ImTools.ImMapEntry<V> entry) -> ImTools.ImMapTree<V>
~ImTools.ImMapTree<V>.AddOrUpdateLeftOrRightEntry(int key, ImTools.ImMapEntry<V> entry) -> ImTools.ImMapTree<V>
~ImTools.ImMapTree<V>.AddUnsafeLeftOrRightEntry(int key, ImTools.ImMapEntry<V> entry) -> ImTools.ImMapTree<V>
~ImTools.ImMapTree<V>.Left -> ImTools.ImMap<V>
~ImTools.ImMapTree<V>.Right -> ImTools.ImMap<V>
~ImTools.ImZipper<T>.Append(T focus) -> ImTools.ImZipper<T>
~ImTools.ImZipper<T>.Insert(T focus) -> ImTools.ImZipper<T>
~ImTools.ImZipper<T>.Map<R>(System.Func<T, int, R> map) -> ImTools.ImZipper<R>
~ImTools.ImZipper<T>.Map<R>(System.Func<T, R> map) -> ImTools.ImZipper<R>
~ImTools.ImZipper<T>.PopLeft() -> ImTools.ImZipper<T>
~ImTools.ImZipper<T>.PopRight() -> ImTools.ImZipper<T>
~ImTools.ImZipper<T>.PushLeft(T focus) -> ImTools.ImZipper<T>
~ImTools.ImZipper<T>.PushRight(T focus) -> ImTools.ImZipper<T>
~ImTools.ImZipper<T>.ShiftLeft() -> ImTools.ImZipper<T>
~ImTools.ImZipper<T>.ShiftRight() -> ImTools.ImZipper<T>
~ImTools.ImZipper<T>.WithFocus(T focus) -> ImTools.ImZipper<T>
~ImTools.IPrintable.Print(System.Text.StringBuilder s, System.Func<System.Text.StringBuilder, object, System.Text.StringBuilder> printer) -> System.Text.StringBuilder
~ImTools.Item<TItem, T>
~ImTools.Item<TItem, T>.item.Equals(ImTools.Item<TItem, T>.item other) -> bool
~ImTools.Item<TItem>
~ImTools.Item<TItem>.item.Equals(ImTools.Item<TItem>.item other) -> bool
~ImTools.KV<K, V>.Print(System.Text.StringBuilder s, System.Func<System.Text.StringBuilder, object, System.Text.StringBuilder> printer) -> System.Text.StringBuilder
~ImTools.Ref<T>
~ImTools.Ref<T>.Ref(T initialValue = null) -> void
~ImTools.Ref<T>.SetNonAtomic(T newValue) -> T
~ImTools.Ref<T>.Swap(System.Func<T, T> getNewValue) -> T
~ImTools.Ref<T>.Swap(T newValue) -> T
~ImTools.Ref<T>.Swap<A, B>(A a, B b, System.Func<T, A, B, T> getNewValue) -> T
~ImTools.Ref<T>.Swap<A>(A a, System.Func<T, A, T> getNewValue) -> T
~ImTools.Ref<T>.TrySwapIfStillCurrent(T currentValue, T newValue) -> bool
~ImTools.Ref<T>.Value.get -> T
~ImTools.StackPool<T>
~ImTools.StackPool<T>.RentOrDefault() -> T
~ImTools.StackPool<T>.Return(T x) -> void
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case1.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8, System.Func<T9, R> map9, System.Func<T10, R> map10) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case10.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8, System.Func<T9, R> map9, System.Func<T10, R> map10) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case2.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8, System.Func<T9, R> map9, System.Func<T10, R> map10) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case3.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8, System.Func<T9, R> map9, System.Func<T10, R> map10) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case4.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8, System.Func<T9, R> map9, System.Func<T10, R> map10) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case5.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8, System.Func<T9, R> map9, System.Func<T10, R> map10) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case6.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8, System.Func<T9, R> map9, System.Func<T10, R> map10) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case7.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8, System.Func<T9, R> map9, System.Func<T10, R> map10) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case8.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8, System.Func<T9, R> map9, System.Func<T10, R> map10) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case9.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8, System.Func<T9, R> map9, System.Func<T10, R> map10) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.union.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8, System.Func<T9, R> map9, System.Func<T10, R> map10) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case1.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8, System.Func<T9, R> map9) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case2.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8, System.Func<T9, R> map9) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case3.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8, System.Func<T9, R> map9) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case4.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8, System.Func<T9, R> map9) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case5.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8, System.Func<T9, R> map9) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case6.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8, System.Func<T9, R> map9) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case7.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8, System.Func<T9, R> map9) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case8.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8, System.Func<T9, R> map9) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case9.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8, System.Func<T9, R> map9) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.union.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8, System.Func<T9, R> map9) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case1.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case2.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case3.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case4.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case5.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case6.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case7.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case8.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.union.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7, System.Func<T8, R> map8) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case1.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case2.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case3.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case4.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case5.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case6.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case7.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.union.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6, System.Func<T7, R> map7) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case1.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case2.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case3.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case4.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case5.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case6.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.union.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5, System.Func<T6, R> map6) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case1.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case2.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case3.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case4.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case5.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4, T5>.union.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4, System.Func<T5, R> map5) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4>.case1.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4>.case2.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4>.case3.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4>.case4.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4) -> R
~ImTools.Union<TUnion, T1, T2, T3, T4>.union.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3, System.Func<T4, R> map4) -> R
~ImTools.Union<TUnion, T1, T2, T3>.case1.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3) -> R
~ImTools.Union<TUnion, T1, T2, T3>.case2.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3) -> R
~ImTools.Union<TUnion, T1, T2, T3>.case3.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3) -> R
~ImTools.Union<TUnion, T1, T2, T3>.union.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2, System.Func<T3, R> map3) -> R
~ImTools.Union<TUnion, T1, T2>.case1.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2) -> R
~ImTools.Union<TUnion, T1, T2>.case2.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2) -> R
~ImTools.Union<TUnion, T1, T2>.union.Match<R>(System.Func<T1, R> map1, System.Func<T2, R> map2) -> R
~override DryIoc.Container.ToString() -> string
~override DryIoc.CurrentScopeReuse.ToString() -> string
~override DryIoc.DefaultDynamicKey.Equals(object key) -> bool
~override DryIoc.DefaultDynamicKey.ToString() -> string
~override DryIoc.DefaultKey.Equals(object key) -> bool
~override DryIoc.DefaultKey.ToString() -> string
~override DryIoc.DelegateFactory.CreateExpressionOrDefault(DryIoc.Request request) -> FastExpressionCompiler.LightExpression.Expression
~override DryIoc.DelegateFactory.GetDelegateOrDefault(DryIoc.Request request) -> DryIoc.FactoryDelegate
~override DryIoc.DelegateFactory.ImplementationType.get -> System.Type
~override DryIoc.ExpressionFactory.CreateExpressionOrDefault(DryIoc.Request request) -> FastExpressionCompiler.LightExpression.Expression
~override DryIoc.Factory.ToString() -> string
~override DryIoc.FactoryMethod.ToString() -> string
~override DryIoc.Made.ToString() -> string
~override DryIoc.OpenGenericTypeKey.Equals(object obj) -> bool
~override DryIoc.OpenGenericTypeKey.ToString() -> string
~override DryIoc.ParameterServiceInfo.ToString() -> string
~override DryIoc.ReflectionFactory.CreateExpressionOrDefault(DryIoc.Request request) -> FastExpressionCompiler.LightExpression.Expression
~override DryIoc.ReflectionFactory.FactoryGenerator.get -> DryIoc.IConcreteFactoryGenerator
~override DryIoc.ReflectionFactory.ImplementationType.get -> System.Type
~override DryIoc.ReflectionFactory.Made.get -> DryIoc.Made
~override DryIoc.RegisteredInstanceFactory.CreateExpressionOrDefault(DryIoc.Request request) -> FastExpressionCompiler.LightExpression.Expression
~override DryIoc.RegisteredInstanceFactory.GetDelegateOrDefault(DryIoc.Request request) -> DryIoc.FactoryDelegate
~override DryIoc.RegisteredInstanceFactory.GetExpressionOrDefault(DryIoc.Request request) -> FastExpressionCompiler.LightExpression.Expression
~override DryIoc.RegisteredInstanceFactory.ImplementationType.get -> System.Type
~override DryIoc.Request.Equals(object obj) -> bool
~override DryIoc.Request.ToString() -> string
~override DryIoc.ResolutionScopeName.ToString() -> string
~override DryIoc.Rules.ToString() -> string
~override DryIoc.Scope.ToString() -> string
~override DryIoc.ServiceDetails.ToString() -> string
~override DryIoc.ServiceInfo.ToString() -> string
~override DryIoc.ServiceRegistrationInfo.ToString() -> string
~override DryIoc.SingletonReuse.ToString() -> string
~override FastExpressionCompiler.LightExpression.BinaryExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.BinaryExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.BlockExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.BlockExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.CoalesceConversionBinaryExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.ConditionalExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.ConditionalExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.ConstantExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.ConstantExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.ConvertWithMethodUnaryExpression.Method.get -> System.Reflection.MethodInfo
~override FastExpressionCompiler.LightExpression.ConvertWithMethodUnaryExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.DefaultExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.DefaultExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.Expression.ToString() -> string
~override FastExpressionCompiler.LightExpression.FieldExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.FieldExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.FiveArgumentsMethodCallExpression.Arguments.get -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.Expression>
~override FastExpressionCompiler.LightExpression.FiveArgumentsNewExpression.Arguments.get -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.Expression>
~override FastExpressionCompiler.LightExpression.FourArgumentsMethodCallExpression.Arguments.get -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.Expression>
~override FastExpressionCompiler.LightExpression.FourArgumentsNewExpression.Arguments.get -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.Expression>
~override FastExpressionCompiler.LightExpression.GotoExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.GotoExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.IndexExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.IndexExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.InstanceFiveArgumentsMethodCallExpression.Object.get -> FastExpressionCompiler.LightExpression.Expression
~override FastExpressionCompiler.LightExpression.InstanceFourArgumentsMethodCallExpression.Object.get -> FastExpressionCompiler.LightExpression.Expression
~override FastExpressionCompiler.LightExpression.InstanceManyArgumentsMethodCallExpression.Object.get -> FastExpressionCompiler.LightExpression.Expression
~override FastExpressionCompiler.LightExpression.InstanceMethodCallExpression.Object.get -> FastExpressionCompiler.LightExpression.Expression
~override FastExpressionCompiler.LightExpression.InstanceOneArgumentMethodCallExpression.Object.get -> FastExpressionCompiler.LightExpression.Expression
~override FastExpressionCompiler.LightExpression.InstanceThreeArgumentsMethodCallExpression.Object.get -> FastExpressionCompiler.LightExpression.Expression
~override FastExpressionCompiler.LightExpression.InstanceTwoArgumentsMethodCallExpression.Object.get -> FastExpressionCompiler.LightExpression.Expression
~override FastExpressionCompiler.LightExpression.InvocationExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.InvocationExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.LabelExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.LabelExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.LambdaExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.LambdaExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.LoopExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.LoopExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.ManyArgumentsMethodCallExpression.Arguments.get -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.Expression>
~override FastExpressionCompiler.LightExpression.ManyArgumentsNewExpression.Arguments.get -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.Expression>
~override FastExpressionCompiler.LightExpression.ManyParametersExpression<TDelegate>.Parameters.get -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.ParameterExpression>
~override FastExpressionCompiler.LightExpression.ManyParametersLambdaExpression.Parameters.get -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.ParameterExpression>
~override FastExpressionCompiler.LightExpression.MemberAssignment.ToCodeString(System.Text.StringBuilder sb, int lineIdent, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.MemberInitExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.MemberInitExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.MethodCallExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.MethodCallExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.NewArrayExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.NewArrayExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.NewExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.NewExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.NewValueTypeExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.NewValueTypeExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.OneArgumentMethodCallExpression.Arguments.get -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.Expression>
~override FastExpressionCompiler.LightExpression.OneArgumentNewExpression.Arguments.get -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.Expression>
~override FastExpressionCompiler.LightExpression.OneVariableTwoExpressionBlockExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.OneVariableTwoExpressionBlockExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.ParameterExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.ParameterExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.PropertyExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.PropertyExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.SwitchExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.SwitchExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.ThreeArgumentsMethodCallExpression.Arguments.get -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.Expression>
~override FastExpressionCompiler.LightExpression.ThreeArgumentsNewExpression.Arguments.get -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.Expression>
~override FastExpressionCompiler.LightExpression.TryExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.TryExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.TwoArgumentsMethodCallExpression.Arguments.get -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.Expression>
~override FastExpressionCompiler.LightExpression.TwoArgumentsNewExpression.Arguments.get -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.Expression>
~override FastExpressionCompiler.LightExpression.TypeBinaryExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.TypeBinaryExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.TypedConstantExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.TypedConstantExpression<T>.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.TypedUnaryExpression.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.TypedUnaryExpression<T>.Type.get -> System.Type
~override FastExpressionCompiler.LightExpression.UnaryExpression.ToCodeString(System.Text.StringBuilder sb, int lineIdent = 0, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null, int identSpaces = 2) -> System.Text.StringBuilder
~override FastExpressionCompiler.LightExpression.UnaryExpression.Type.get -> System.Type
~override ImTools.Box<TBox, T>.Equals(object obj) -> bool
~override ImTools.Box<TBox, T>.ToString() -> string
~override ImTools.GrowingList<T>.ToString() -> string
~override ImTools.ImHashMap<K, V>.ToString() -> string
~override ImTools.ImHashMapEntry<K, V>.ToString() -> string
~override ImTools.ImList<T>.ToString() -> string
~override ImTools.ImMap<V>.ToString() -> string
~override ImTools.ImMapBranch<V>.ToString() -> string
~override ImTools.ImMapEntry<V>.ToString() -> string
~override ImTools.ImMapTree<V>.ToString() -> string
~override ImTools.ImZipper<T>.ToString() -> string
~override ImTools.Item<TItem, T>.item.Equals(object obj) -> bool
~override ImTools.Item<TItem, T>.item.ToString() -> string
~override ImTools.Item<TItem>.item.Equals(object obj) -> bool
~override ImTools.Item<TItem>.item.ToString() -> string
~override ImTools.KV<K, V>.Equals(object obj) -> bool
~override ImTools.KV<K, V>.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case1.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case1.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case10.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case10.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case2.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case2.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case3.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case3.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case4.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case4.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case5.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case5.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case6.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case6.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case7.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case7.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case8.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case8.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case9.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.case9.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case1.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case1.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case2.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case2.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case3.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case3.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case4.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case4.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case5.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case5.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case6.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case6.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case7.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case7.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case8.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case8.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case9.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.case9.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case1.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case1.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case2.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case2.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case3.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case3.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case4.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case4.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case5.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case5.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case6.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case6.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case7.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case7.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case8.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.case8.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case1.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case1.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case2.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case2.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case3.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case3.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case4.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case4.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case5.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case5.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case6.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case6.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case7.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.case7.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case1.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case1.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case2.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case2.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case3.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case3.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case4.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case4.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case5.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case5.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case6.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.case6.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case1.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case1.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case2.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case2.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case3.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case3.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case4.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case4.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case5.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4, T5>.case5.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4>.case1.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4>.case1.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4>.case2.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4>.case2.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4>.case3.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4>.case3.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3, T4>.case4.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3, T4>.case4.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3>.case1.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3>.case1.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3>.case2.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3>.case2.ToString() -> string
~override ImTools.Union<TUnion, T1, T2, T3>.case3.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2, T3>.case3.ToString() -> string
~override ImTools.Union<TUnion, T1, T2>.case1.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2>.case1.ToString() -> string
~override ImTools.Union<TUnion, T1, T2>.case2.Equals(object obj) -> bool
~override ImTools.Union<TUnion, T1, T2>.case2.ToString() -> string
~override ImTools.Unit.Equals(object obj) -> bool
~override ImTools.Unit.ToString() -> string
~readonly DryIoc.ContainerTools.GeneratedExpressions.Errors -> System.Collections.Generic.List<System.Collections.Generic.KeyValuePair<DryIoc.ServiceInfo, DryIoc.ContainerException>>
~readonly DryIoc.ContainerTools.GeneratedExpressions.ResolveDependencies -> System.Collections.Generic.List<System.Collections.Generic.KeyValuePair<DryIoc.Request, System.Linq.Expressions.Expression>>
~readonly DryIoc.ContainerTools.GeneratedExpressions.Roots -> System.Collections.Generic.List<System.Collections.Generic.KeyValuePair<DryIoc.ServiceInfo, System.Linq.Expressions.Expression<DryIoc.FactoryDelegate>>>
~readonly DryIoc.DynamicRegistration.Factory -> DryIoc.Factory
~readonly DryIoc.DynamicRegistration.ServiceKey -> object
~readonly DryIoc.FactoryMethod.ConstructorOrMethodOrMember -> System.Reflection.MemberInfo
~readonly DryIoc.FactoryMethod.FactoryExpression -> FastExpressionCompiler.LightExpression.Expression
~readonly DryIoc.FactoryMethod.FactoryServiceInfo -> DryIoc.ServiceInfo
~readonly DryIoc.HiddenDisposable.Value -> object
~readonly DryIoc.Interpreter.ParentLambdaArgs.ParamExprs -> object
~readonly DryIoc.Interpreter.ParentLambdaArgs.ParamValues -> object
~readonly DryIoc.Interpreter.ParentLambdaArgs.ParentWithArgs -> DryIoc.Interpreter.ParentLambdaArgs
~readonly DryIoc.LazyEnumerable<TService>.Items -> System.Collections.Generic.IEnumerable<TService>
~readonly DryIoc.OpenGenericTypeKey.RequiredServiceType -> System.Type
~readonly DryIoc.OpenGenericTypeKey.ServiceKey -> object
~readonly DryIoc.ParameterServiceInfo.DereferencedParameterType -> System.Type
~readonly DryIoc.ParameterServiceInfo.Parameter -> System.Reflection.ParameterInfo
~readonly DryIoc.RegisteredInstanceFactory.Instance -> object
~readonly DryIoc.ResolutionScopeName.ServiceKey -> object
~readonly DryIoc.ResolutionScopeName.ServiceType -> System.Type
~readonly DryIoc.ServiceDetails.Metadata -> object
~readonly DryIoc.ServiceDetails.MetadataKey -> string
~readonly DryIoc.ServiceDetails.RequiredServiceType -> System.Type
~readonly DryIoc.ServiceDetails.ServiceKey -> object
~readonly FastExpressionCompiler.LightExpression.ArgumentsExpression.Arguments -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.Expression>
~readonly FastExpressionCompiler.LightExpression.BinaryExpression.Left -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.BinaryExpression.Right -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.BlockExpression.Expressions -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.Expression>
~readonly FastExpressionCompiler.LightExpression.BlockExpression.Variables -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.ParameterExpression>
~readonly FastExpressionCompiler.LightExpression.CatchBlock.Body -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.CatchBlock.Filter -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.CatchBlock.Test -> System.Type
~readonly FastExpressionCompiler.LightExpression.CatchBlock.Variable -> FastExpressionCompiler.LightExpression.ParameterExpression
~readonly FastExpressionCompiler.LightExpression.CoalesceConversionBinaryExpression.Conversion -> FastExpressionCompiler.LightExpression.LambdaExpression
~readonly FastExpressionCompiler.LightExpression.ConditionalExpression.IfFalse -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.ConditionalExpression.IfTrue -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.ConditionalExpression.Test -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.ConstantExpression.Value -> object
~readonly FastExpressionCompiler.LightExpression.ExpressionCompiler.ArrayClosure.ConstantsAndNestedLambdas -> object[]
~readonly FastExpressionCompiler.LightExpression.ExpressionCompiler.ArrayClosureWithNonPassedParams.NonPassedParams -> object[]
~readonly FastExpressionCompiler.LightExpression.ExpressionCompiler.NestedLambdaWithConstantsAndNestedLambdas.ConstantsAndNestedLambdas -> object
~readonly FastExpressionCompiler.LightExpression.ExpressionCompiler.NestedLambdaWithConstantsAndNestedLambdas.NestedLambda -> object
~readonly FastExpressionCompiler.LightExpression.FiveArgumentsMethodCallExpression.Argument0 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.FiveArgumentsMethodCallExpression.Argument1 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.FiveArgumentsMethodCallExpression.Argument2 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.FiveArgumentsMethodCallExpression.Argument3 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.FiveArgumentsMethodCallExpression.Argument4 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.FiveArgumentsNewExpression.Argument0 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.FiveArgumentsNewExpression.Argument1 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.FiveArgumentsNewExpression.Argument2 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.FiveArgumentsNewExpression.Argument3 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.FiveArgumentsNewExpression.Argument4 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.FourArgumentsMethodCallExpression.Argument0 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.FourArgumentsMethodCallExpression.Argument1 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.FourArgumentsMethodCallExpression.Argument2 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.FourArgumentsMethodCallExpression.Argument3 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.FourArgumentsNewExpression.Argument0 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.FourArgumentsNewExpression.Argument1 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.FourArgumentsNewExpression.Argument2 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.FourArgumentsNewExpression.Argument3 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.GotoExpression.Target -> System.Linq.Expressions.LabelTarget
~readonly FastExpressionCompiler.LightExpression.GotoExpression.Value -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.IndexExpression.Indexer -> System.Reflection.PropertyInfo
~readonly FastExpressionCompiler.LightExpression.IndexExpression.Object -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.InvocationExpression.Expression -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.LabelExpression.DefaultValue -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.LabelExpression.Target -> System.Linq.Expressions.LabelTarget
~readonly FastExpressionCompiler.LightExpression.LambdaExpression.Body -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.LambdaExpression.ReturnType -> System.Type
~readonly FastExpressionCompiler.LightExpression.LoopExpression.Body -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.LoopExpression.BreakLabel -> System.Linq.Expressions.LabelTarget
~readonly FastExpressionCompiler.LightExpression.LoopExpression.ContinueLabel -> System.Linq.Expressions.LabelTarget
~readonly FastExpressionCompiler.LightExpression.MemberAssignment.Expression -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.MemberBinding.Member -> System.Reflection.MemberInfo
~readonly FastExpressionCompiler.LightExpression.MemberExpression.Expression -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.MemberExpression.Member -> System.Reflection.MemberInfo
~readonly FastExpressionCompiler.LightExpression.MemberInitExpression.Bindings -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.MemberBinding>
~readonly FastExpressionCompiler.LightExpression.MemberInitExpression.Expression -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.MethodCallExpression.Method -> System.Reflection.MethodInfo
~readonly FastExpressionCompiler.LightExpression.NewExpression.Constructor -> System.Reflection.ConstructorInfo
~readonly FastExpressionCompiler.LightExpression.OneArgumentMethodCallExpression.Argument -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.OneArgumentNewExpression.Argument -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.OneVariableTwoExpressionBlockExpression.Expression1 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.OneVariableTwoExpressionBlockExpression.Expression2 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.OneVariableTwoExpressionBlockExpression.Variable -> FastExpressionCompiler.LightExpression.ParameterExpression
~readonly FastExpressionCompiler.LightExpression.ParameterExpression.Name -> string
~readonly FastExpressionCompiler.LightExpression.SwitchCase.Body -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.SwitchCase.TestValues -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.Expression>
~readonly FastExpressionCompiler.LightExpression.SwitchExpression.Comparison -> System.Reflection.MethodInfo
~readonly FastExpressionCompiler.LightExpression.SwitchExpression.DefaultBody -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.SwitchExpression.SwitchValue -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.ThreeArgumentsMethodCallExpression.Argument0 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.ThreeArgumentsMethodCallExpression.Argument1 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.ThreeArgumentsMethodCallExpression.Argument2 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.ThreeArgumentsNewExpression.Argument0 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.ThreeArgumentsNewExpression.Argument1 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.ThreeArgumentsNewExpression.Argument2 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.TryExpression.Body -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.TryExpression.Finally -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.TwoArgumentsMethodCallExpression.Argument0 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.TwoArgumentsMethodCallExpression.Argument1 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.TwoArgumentsNewExpression.Argument0 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.TwoArgumentsNewExpression.Argument1 -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.TypeBinaryExpression.Expression -> FastExpressionCompiler.LightExpression.Expression
~readonly FastExpressionCompiler.LightExpression.UnaryExpression.Operand -> FastExpressionCompiler.LightExpression.Expression
~readonly ImTools.ImHashMap<K, V>.Entry -> ImTools.ImHashMapEntry<K, V>
~readonly ImTools.ImHashMapConflicts<K, V>.Conflicts -> ImTools.ImHashMapEntry<K, V>[]
~readonly ImTools.ImList<T>.Tail -> ImTools.ImList<T>
~readonly ImTools.ImMapBranch<V>.Entry -> ImTools.ImMapEntry<V>
~readonly ImTools.ImMapTree<V>.Entry -> ImTools.ImMapEntry<V>
~readonly ImTools.ImZipper<T>.Left -> ImTools.ImList<T>
~readonly ImTools.ImZipper<T>.Right -> ImTools.ImList<T>
~static DryIoc.Arg.ArgIndexMethodName -> string
~static DryIoc.Arg.Of<TRequired>(DryIoc.IfUnresolved ifUnresolved, object serviceKey) -> TRequired
~static DryIoc.Arg.Of<TRequired>(object serviceKey) -> TRequired
~static DryIoc.Arg.Of<TRequired>(string metadataKey, object metadata) -> TRequired
~static DryIoc.Arg.Of<TRequired>(TRequired defaultValue, DryIoc.IfUnresolved ifUnresolved, object serviceKey) -> TRequired
~static DryIoc.Arg.Of<TService, TRequired>(DryIoc.IfUnresolved ifUnresolved, object serviceKey) -> TService
~static DryIoc.Arg.Of<TService, TRequired>(object serviceKey) -> TService
~static DryIoc.Arg.Of<TService, TRequired>(string metadataKey, object metadata) -> TService
~static DryIoc.CompositeScopeName.Of(object[] names) -> DryIoc.CompositeScopeName
~static DryIoc.Container.NewSingletonScope() -> DryIoc.IScope
~static DryIoc.Container.ResolveManyResult.Of(DryIoc.FactoryDelegate factoryDelegate, object serviceKey = null, System.Type requiredServiceType = null) -> DryIoc.Container.ResolveManyResult
~static DryIoc.ContainerException.FormatMessage(string errorName, string message) -> string
~static DryIoc.ContainerException.GetMessage(DryIoc.ErrorCheck errorCheck, int errorCode) -> string
~static DryIoc.ContainerException.Of(DryIoc.ErrorCheck errorCheck, int errorCode, object arg0, object arg1 = null, object arg2 = null, object arg3 = null, System.Exception innerException = null) -> DryIoc.ContainerException
~static DryIoc.ContainerException.Print(object arg) -> string
~static DryIoc.ContainerTools.ClearCache(this DryIoc.IContainer container, System.Type serviceType, DryIoc.FactoryType? factoryType = null, object serviceKey = null) -> bool
~static DryIoc.ContainerTools.ClearCache<T>(this DryIoc.IContainer container, DryIoc.FactoryType? factoryType = null, object serviceKey = null) -> bool
~static DryIoc.ContainerTools.CreateFacade(this DryIoc.IContainer container, string facadeKey = "@facade") -> DryIoc.IContainer
~static DryIoc.ContainerTools.GenerateResolutionExpressions(this DryIoc.IContainer container, params DryIoc.ServiceInfo[] roots) -> DryIoc.ContainerTools.GeneratedExpressions
~static DryIoc.ContainerTools.GenerateResolutionExpressions(this DryIoc.IContainer container, System.Func<DryIoc.ServiceRegistrationInfo, bool> condition) -> DryIoc.ContainerTools.GeneratedExpressions
~static DryIoc.ContainerTools.GenerateResolutionExpressions(this DryIoc.IContainer container, System.Func<System.Collections.Generic.IEnumerable<DryIoc.ServiceRegistrationInfo>, System.Collections.Generic.IEnumerable<DryIoc.ServiceInfo>> getRoots = null, bool allowRuntimeState = false) -> DryIoc.ContainerTools.GeneratedExpressions
~static DryIoc.ContainerTools.GetRequestExpression(this DryIoc.IContainer container, DryIoc.Request request, DryIoc.RequestFlags requestParentFlags = (DryIoc.RequestFlags)0) -> FastExpressionCompiler.LightExpression.Expression
~static DryIoc.ContainerTools.InjectPropertiesAndFields<TService>(this DryIoc.IResolverContext r, TService instance) -> TService
~static DryIoc.ContainerTools.InjectPropertiesAndFields<TService>(this DryIoc.IResolverContext r, TService instance, params string[] propertyAndFieldNames) -> TService
~static DryIoc.ContainerTools.New(this DryIoc.IContainer container, System.Type concreteType, DryIoc.Made made = null, DryIoc.RegistrySharing registrySharing = DryIoc.RegistrySharing.CloneButKeepCache) -> object
~static DryIoc.ContainerTools.New(this DryIoc.IContainer container, System.Type concreteType, DryIoc.Setup setup, DryIoc.Made made = null, DryIoc.RegistrySharing registrySharing = DryIoc.RegistrySharing.CloneButKeepCache) -> object
~static DryIoc.ContainerTools.New<T>(this DryIoc.IContainer container, DryIoc.Made made = null, DryIoc.RegistrySharing registrySharing = DryIoc.RegistrySharing.CloneButKeepCache) -> T
~static DryIoc.ContainerTools.New<T>(this DryIoc.IContainer container, DryIoc.Made.TypedMade<T> made, DryIoc.RegistrySharing registrySharing = DryIoc.RegistrySharing.CloneButKeepCache) -> T
~static DryIoc.ContainerTools.RegisterMapping(this DryIoc.IContainer container, System.Type serviceType, System.Type registeredServiceType, object serviceKey = null, object registeredServiceKey = null) -> void
~static DryIoc.ContainerTools.RegisterMapping<TService, TRegisteredService>(this DryIoc.IContainer container, object serviceKey = null, object registeredServiceKey = null) -> void
~static DryIoc.ContainerTools.RegisterPlaceholder(this DryIoc.IContainer container, System.Type serviceType, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.ContainerTools.RegisterPlaceholder<TService>(this DryIoc.IContainer container, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.ContainerTools.Validate(this DryIoc.IContainer container, params DryIoc.ServiceInfo[] roots) -> System.Collections.Generic.KeyValuePair<DryIoc.ServiceInfo, DryIoc.ContainerException>[]
~static DryIoc.ContainerTools.Validate(this DryIoc.IContainer container, System.Func<DryIoc.ServiceRegistrationInfo, bool> condition = null) -> System.Collections.Generic.KeyValuePair<DryIoc.ServiceInfo, DryIoc.ContainerException>[]
~static DryIoc.ContainerTools.With(this DryIoc.IContainer container, System.Func<DryIoc.Rules, DryIoc.Rules> configure = null, DryIoc.IScopeContext scopeContext = null) -> DryIoc.IContainer
~static DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(this DryIoc.IContainer container, DryIoc.IReuse reuse, DryIoc.Setup setup, params System.Type[] implTypes) -> DryIoc.IContainer
~static DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(this DryIoc.IContainer container, DryIoc.IReuse reuse, params System.Type[] implTypes) -> DryIoc.IContainer
~static DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(this DryIoc.IContainer container, params System.Reflection.Assembly[] implTypeAssemblies) -> DryIoc.IContainer
~static DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(this DryIoc.IContainer container, params System.Type[] implTypes) -> DryIoc.IContainer
~static DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(this DryIoc.IContainer container, System.Collections.Generic.IEnumerable<System.Reflection.Assembly> implTypeAssemblies) -> DryIoc.IContainer
~static DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(this DryIoc.IContainer container, System.Func<System.Type, object, System.Collections.Generic.IEnumerable<System.Reflection.Assembly>> getImplTypeAssemblies, System.Func<System.Type, DryIoc.Factory> factory = null) -> DryIoc.IContainer
~static DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(this DryIoc.IContainer container, System.Func<System.Type, object, System.Collections.Generic.IEnumerable<System.Type>> getImplTypes, System.Func<System.Type, DryIoc.Factory> factory = null) -> DryIoc.IContainer
~static DryIoc.ContainerTools.WithAutoFallbackResolution(this DryIoc.IContainer container, System.Collections.Generic.IEnumerable<System.Reflection.Assembly> implTypeAssemblies, System.Func<DryIoc.IReuse, DryIoc.Request, DryIoc.IReuse> changeDefaultReuse = null, System.Func<DryIoc.Request, bool> condition = null) -> DryIoc.IContainer
~static DryIoc.ContainerTools.WithAutoFallbackResolution(this DryIoc.IContainer container, System.Collections.Generic.IEnumerable<System.Type> implTypes, System.Func<DryIoc.IReuse, DryIoc.Request, DryIoc.IReuse> changeDefaultReuse = null, System.Func<DryIoc.Request, bool> condition = null) -> DryIoc.IContainer
~static DryIoc.ContainerTools.WithDependencies(this DryIoc.IContainer container, DryIoc.ParameterSelector parameters = null, DryIoc.PropertiesAndFieldsSelector propertiesAndFields = null) -> DryIoc.IContainer
~static DryIoc.ContainerTools.WithExpressionGeneration(this DryIoc.IContainer container, bool allowRuntimeState = false) -> DryIoc.IContainer
~static DryIoc.ContainerTools.WithoutCache(this DryIoc.IContainer container) -> DryIoc.IContainer
~static DryIoc.ContainerTools.WithoutSingletonsAndCache(this DryIoc.IContainer container) -> DryIoc.IContainer
~static DryIoc.ContainerTools.WithRegistrationsCopy(this DryIoc.IContainer container, bool preserveCache = false) -> DryIoc.IContainer
~static DryIoc.CurrentScopeReuse.GetNameScoped(DryIoc.IResolverContext r, object scopeName, bool throwIfNoScope, int id, DryIoc.CreateScopedValue createValue, int disposalIndex) -> object
~static DryIoc.CurrentScopeReuse.GetNameScopedViaFactoryDelegate(DryIoc.IResolverContext r, object scopeName, bool throwIfNoScope, int id, DryIoc.FactoryDelegate createValue, int disposalIndex) -> object
~static DryIoc.CurrentScopeReuse.GetScoped(DryIoc.IResolverContext r, bool throwIfNoScope, int id, DryIoc.CreateScopedValue createValue, int disposalIndex) -> object
~static DryIoc.CurrentScopeReuse.GetScopedOrSingleton(DryIoc.IResolverContext r, int id, DryIoc.CreateScopedValue createValue, int disposalIndex) -> object
~static DryIoc.CurrentScopeReuse.GetScopedOrSingletonViaFactoryDelegate(DryIoc.IResolverContext r, int id, DryIoc.FactoryDelegate createValue, int disposalIndex) -> object
~static DryIoc.CurrentScopeReuse.GetScopedViaFactoryDelegate(DryIoc.IResolverContext r, bool throwIfNoScope, int id, DryIoc.FactoryDelegate createValue, int disposalIndex) -> object
~static DryIoc.CurrentScopeReuse.GetScopedViaFactoryDelegateNoDisposalIndex(DryIoc.IResolverContext r, bool throwIfNoScope, int id, DryIoc.FactoryDelegate createValue) -> object
~static DryIoc.CurrentScopeReuse.TrackNameScoped(DryIoc.IResolverContext r, object scopeName, bool throwIfNoScope, object item) -> object
~static DryIoc.CurrentScopeReuse.TrackScoped(DryIoc.IResolverContext r, bool throwIfNoScope, object item) -> object
~static DryIoc.CurrentScopeReuse.TrackScopedOrSingleton(DryIoc.IResolverContext r, object item) -> object
~static DryIoc.DefaultDynamicKey.Of(int registrationOrder) -> DryIoc.DefaultDynamicKey
~static DryIoc.DefaultKey.Of(int registrationOrder) -> DryIoc.DefaultKey
~static DryIoc.Error.NameOf(int error) -> string
~static DryIoc.FactoryDelegateCompiler.CompileToFactoryDelegate(this FastExpressionCompiler.LightExpression.Expression expression, bool useFastExpressionCompiler = false) -> DryIoc.FactoryDelegate
~static DryIoc.FactoryDelegateCompiler.CompileToFactoryDelegate(this FastExpressionCompiler.LightExpression.Expression expression, bool useFastExpressionCompiler, bool preferInterpretation) -> DryIoc.FactoryDelegate
~static DryIoc.FactoryDelegateCompiler.CompileToFactoryDelegate(this FastExpressionCompiler.LightExpression.Expression expression, System.Type factoryDelegateType, System.Type resultType, bool useFastExpressionCompiler, bool preferInterpretation) -> object
~static DryIoc.FactoryDelegateCompiler.NormalizeExpression(this FastExpressionCompiler.LightExpression.Expression expr) -> FastExpressionCompiler.LightExpression.Expression
~static DryIoc.FactoryDelegateCompiler.ToExpression(this FastExpressionCompiler.LightExpression.Expression expr) -> System.Linq.Expressions.Expression
~static DryIoc.FactoryDelegateCompiler.WrapInFactoryExpression(this FastExpressionCompiler.LightExpression.Expression expression) -> FastExpressionCompiler.LightExpression.Expression<DryIoc.FactoryDelegate>
~static DryIoc.FactoryMethod.Constructor(bool mostResolvable = false, bool includeNonPublic = false) -> DryIoc.FactoryMethodSelector
~static DryIoc.FactoryMethod.DefaultConstructor(bool includeNonPublic = false) -> DryIoc.FactoryMethodSelector
~static DryIoc.FactoryMethod.Of(System.Reflection.MemberInfo ctorOrMethodOrMember, DryIoc.ServiceInfo factoryInfo = null) -> DryIoc.FactoryMethod
~static DryIoc.FactoryMethod.Of(System.Reflection.MemberInfo methodOrMember, object factoryInstance) -> DryIoc.FactoryMethod
~static DryIoc.FactoryMethod.Of<TFactory>(string methodOrMemberName) -> DryIoc.FactoryMethod
~static DryIoc.Interpreter.TryInterpret(DryIoc.IResolverContext r, FastExpressionCompiler.LightExpression.Expression expr, object paramExprs, object paramValues, DryIoc.Interpreter.ParentLambdaArgs parentArgs, bool useFec, out object result) -> bool
~static DryIoc.Interpreter.TryInterpretAndUnwrapContainerException(DryIoc.IResolverContext r, FastExpressionCompiler.LightExpression.Expression expr, bool useFec, out object result) -> bool
~static DryIoc.Made.implicit operator DryIoc.Made(DryIoc.FactoryMethodSelector factoryMethod) -> DryIoc.Made
~static DryIoc.Made.implicit operator DryIoc.Made(DryIoc.ParameterSelector parameters) -> DryIoc.Made
~static DryIoc.Made.implicit operator DryIoc.Made(DryIoc.PropertiesAndFieldsSelector propertiesAndFields) -> DryIoc.Made
~static DryIoc.Made.Of(DryIoc.FactoryMethod factoryMethod, DryIoc.ParameterSelector parameters = null, DryIoc.PropertiesAndFieldsSelector propertiesAndFields = null) -> DryIoc.Made
~static DryIoc.Made.Of(DryIoc.FactoryMethodSelector factoryMethod = null, DryIoc.ParameterSelector parameters = null, DryIoc.PropertiesAndFieldsSelector propertiesAndFields = null, bool isConditionalImlementation = false) -> DryIoc.Made
~static DryIoc.Made.Of(System.Func<DryIoc.Request, System.Reflection.MemberInfo> getMethodOrMember, DryIoc.ServiceInfo factoryInfo = null, DryIoc.ParameterSelector parameters = null, DryIoc.PropertiesAndFieldsSelector propertiesAndFields = null) -> DryIoc.Made
~static DryIoc.Made.Of(System.Func<DryIoc.Request, System.Reflection.MemberInfo> getMethodOrMember, System.Func<DryIoc.Request, DryIoc.ServiceInfo> factoryInfo, DryIoc.ParameterSelector parameters = null, DryIoc.PropertiesAndFieldsSelector propertiesAndFields = null) -> DryIoc.Made
~static DryIoc.Made.Of(System.Func<DryIoc.Request, System.Type> getImplType, DryIoc.ParameterSelector parameters = null, DryIoc.PropertiesAndFieldsSelector propertiesAndFields = null) -> DryIoc.Made
~static DryIoc.Made.Of(System.Func<System.Type, System.Reflection.ConstructorInfo> getConstructor, DryIoc.ParameterSelector parameters = null, DryIoc.PropertiesAndFieldsSelector propertiesAndFields = null) -> DryIoc.Made
~static DryIoc.Made.Of(System.Reflection.MemberInfo factoryMethodOrMember, DryIoc.ServiceInfo factoryInfo = null, DryIoc.ParameterSelector parameters = null, DryIoc.PropertiesAndFieldsSelector propertiesAndFields = null) -> DryIoc.Made
~static DryIoc.Made.Of<TFactory, TService>(System.Func<DryIoc.Request, DryIoc.ServiceInfo.Typed<TFactory>> getFactoryInfo, System.Linq.Expressions.Expression<System.Func<TFactory, TService>> serviceReturningExpr, params System.Func<DryIoc.Request, object>[] argValues) -> DryIoc.Made.TypedMade<TService>
~static DryIoc.Made.Of<TFactory, TService>(TFactory factoryInstance, System.Linq.Expressions.Expression<System.Func<TFactory, TService>> serviceReturningExpr, params System.Func<DryIoc.Request, object>[] argValues) -> DryIoc.Made.TypedMade<TService>
~static DryIoc.Made.Of<TService>(System.Linq.Expressions.Expression<System.Func<TService>> serviceReturningExpr, params System.Func<DryIoc.Request, object>[] argValues) -> DryIoc.Made.TypedMade<TService>
~static DryIoc.Messages.MessageExtensions.ToEmptyResponse(this System.Threading.Tasks.Task task) -> System.Threading.Tasks.Task<DryIoc.Messages.EmptyResponse>
~static DryIoc.Parameters.And(this DryIoc.ParameterSelector source, DryIoc.ParameterSelector other) -> DryIoc.ParameterSelector
~static DryIoc.Parameters.Details(this DryIoc.ParameterSelector source, System.Func<DryIoc.Request, System.Reflection.ParameterInfo, DryIoc.ServiceDetails> getDetailsOrNull) -> DryIoc.ParameterSelector
~static DryIoc.Parameters.IfUnresolvedReturnDefault -> DryIoc.ParameterSelector
~static DryIoc.Parameters.Name(this DryIoc.ParameterSelector source, string name, System.Func<DryIoc.Request, object> getCustomValue) -> DryIoc.ParameterSelector
~static DryIoc.Parameters.Name(this DryIoc.ParameterSelector source, string name, System.Func<DryIoc.Request, System.Reflection.ParameterInfo, DryIoc.ServiceDetails> getServiceDetails) -> DryIoc.ParameterSelector
~static DryIoc.Parameters.Name(this DryIoc.ParameterSelector source, string name, System.Type requiredServiceType = null, object serviceKey = null, DryIoc.IfUnresolved ifUnresolved = DryIoc.IfUnresolved.Throw, object defaultValue = null, string metadataKey = null, object metadata = null) -> DryIoc.ParameterSelector
~static DryIoc.Parameters.Of -> DryIoc.ParameterSelector
~static DryIoc.Parameters.OverrideWith(this DryIoc.ParameterSelector source, DryIoc.ParameterSelector other) -> DryIoc.ParameterSelector
~static DryIoc.Parameters.Type(this DryIoc.ParameterSelector source, System.Type parameterType, System.Func<DryIoc.Request, object> getCustomValue) -> DryIoc.ParameterSelector
~static DryIoc.Parameters.Type(this DryIoc.ParameterSelector source, System.Type parameterType, System.Type requiredServiceType = null, object serviceKey = null, DryIoc.IfUnresolved ifUnresolved = DryIoc.IfUnresolved.Throw, object defaultValue = null, string metadataKey = null, object metadata = null) -> DryIoc.ParameterSelector
~static DryIoc.Parameters.Type<T>(this DryIoc.ParameterSelector source, System.Func<DryIoc.Request, System.Reflection.ParameterInfo, DryIoc.ServiceDetails> getServiceDetails) -> DryIoc.ParameterSelector
~static DryIoc.Parameters.Type<T>(this DryIoc.ParameterSelector source, System.Func<DryIoc.Request, T> getCustomValue) -> DryIoc.ParameterSelector
~static DryIoc.Parameters.Type<T>(this DryIoc.ParameterSelector source, System.Type requiredServiceType = null, object serviceKey = null, DryIoc.IfUnresolved ifUnresolved = DryIoc.IfUnresolved.Throw, object defaultValue = null, string metadataKey = null, object metadata = null) -> DryIoc.ParameterSelector
~static DryIoc.ParameterServiceInfo.Of(System.Reflection.ParameterInfo parameter) -> DryIoc.ParameterServiceInfo
~static DryIoc.Portable.GetAssemblyTypes(System.Reflection.Assembly a) -> System.Collections.Generic.IEnumerable<System.Type>
~static DryIoc.Portable.GetGetMethodOrNull(this System.Reflection.PropertyInfo p, bool includeNonPublic = false) -> System.Reflection.MethodInfo
~static DryIoc.Portable.GetSetMethodOrNull(this System.Reflection.PropertyInfo p, bool includeNonPublic = false) -> System.Reflection.MethodInfo
~static DryIoc.PrintTools.DefaultItemSeparator -> string
~static DryIoc.PrintTools.GetTypeNameDefault -> System.Func<System.Type, string>
~static DryIoc.PrintTools.Print(this System.Text.StringBuilder s, object x, string quote = "\"", string itemSeparator = null, System.Func<System.Type, string> getTypeName = null) -> System.Text.StringBuilder
~static DryIoc.PrintTools.Print(this System.Text.StringBuilder s, string str, string quote = "\"") -> System.Text.StringBuilder
~static DryIoc.PrintTools.Print(this System.Text.StringBuilder s, System.Collections.IEnumerable items, string separator = ", ", System.Action<System.Text.StringBuilder, object> printItem = null) -> System.Text.StringBuilder
~static DryIoc.PrintTools.Print(this System.Text.StringBuilder s, System.Type type, System.Func<System.Type, string> getTypeName = null) -> System.Text.StringBuilder
~static DryIoc.PrintTools.Print(this System.Type type, System.Func<System.Type, string> getTypeName = null) -> string
~static DryIoc.PropertiesAndFields.All(bool withNonPublic = true, bool withPrimitive = true, bool withFields = true, bool withBase = true, DryIoc.IfUnresolved ifUnresolved = DryIoc.IfUnresolved.ReturnDefaultIfNotRegistered, DryIoc.PropertiesAndFields.GetServiceInfo serviceInfo = null) -> DryIoc.PropertiesAndFieldsSelector
~static DryIoc.PropertiesAndFields.And(this DryIoc.PropertiesAndFieldsSelector source, DryIoc.PropertiesAndFieldsSelector other) -> DryIoc.PropertiesAndFieldsSelector
~static DryIoc.PropertiesAndFields.Auto -> DryIoc.PropertiesAndFieldsSelector
~static DryIoc.PropertiesAndFields.Details(this DryIoc.PropertiesAndFieldsSelector source, string name, System.Func<DryIoc.Request, DryIoc.ServiceDetails> getDetails) -> DryIoc.PropertiesAndFieldsSelector
~static DryIoc.PropertiesAndFields.IsInjectable(this System.Reflection.FieldInfo field, bool withNonPublic = false, bool withPrimitive = false) -> bool
~static DryIoc.PropertiesAndFields.IsInjectable(this System.Reflection.PropertyInfo property, bool withNonPublic = false, bool withPrimitive = false) -> bool
~static DryIoc.PropertiesAndFields.Name(this DryIoc.PropertiesAndFieldsSelector source, string name, System.Func<DryIoc.Request, object> getCustomValue) -> DryIoc.PropertiesAndFieldsSelector
~static DryIoc.PropertiesAndFields.Name(this DryIoc.PropertiesAndFieldsSelector source, string name, System.Type requiredServiceType = null, object serviceKey = null, DryIoc.IfUnresolved ifUnresolved = DryIoc.IfUnresolved.ReturnDefault, object defaultValue = null, string metadataKey = null, object metadata = null) -> DryIoc.PropertiesAndFieldsSelector
~static DryIoc.PropertiesAndFields.Of -> DryIoc.PropertiesAndFieldsSelector
~static DryIoc.PropertiesAndFields.OverrideWith(this DryIoc.PropertiesAndFieldsSelector source, DryIoc.PropertiesAndFieldsSelector other) -> DryIoc.PropertiesAndFieldsSelector
~static DryIoc.PropertiesAndFields.Properties(bool withNonPublic = false, bool withBase = false, DryIoc.IfUnresolved ifUnresolved = DryIoc.IfUnresolved.ReturnDefaultIfNotRegistered) -> DryIoc.PropertiesAndFieldsSelector
~static DryIoc.PropertyOrFieldServiceInfo.Of(System.Reflection.MemberInfo member) -> DryIoc.PropertyOrFieldServiceInfo
~static DryIoc.ReflectionTools.Constructor(this System.Type type, params System.Type[] args) -> System.Reflection.ConstructorInfo
~static DryIoc.ReflectionTools.Constructors(this System.Type type, bool includeNonPublic = false, bool includeStatic = false) -> System.Collections.Generic.IEnumerable<System.Reflection.ConstructorInfo>
~static DryIoc.ReflectionTools.ContainsAllGenericTypeParameters(this System.Type openGenericType, System.Type[] genericParameters) -> bool
~static DryIoc.ReflectionTools.Field(this System.Type type, string name, bool includeBase = false) -> System.Reflection.FieldInfo
~static DryIoc.ReflectionTools.GetAllMembers(this System.Type type, bool includeBase = false) -> System.Collections.Generic.IEnumerable<System.Reflection.MemberInfo>
~static DryIoc.ReflectionTools.GetArrayElementTypeOrNull(this System.Type type) -> System.Type
~static DryIoc.ReflectionTools.GetAssembly(this System.Type type) -> System.Reflection.Assembly
~static DryIoc.ReflectionTools.GetAttributes(this System.Reflection.MemberInfo member, System.Type attributeType = null, bool inherit = false) -> System.Collections.Generic.IEnumerable<System.Attribute>
~static DryIoc.ReflectionTools.GetAttributes(this System.Reflection.ParameterInfo parameter, System.Type attributeType = null, bool inherit = false) -> System.Collections.Generic.IEnumerable<System.Attribute>
~static DryIoc.ReflectionTools.GetAttributes(this System.Type type, System.Type attributeType = null, bool inherit = false) -> System.Attribute[]
~static DryIoc.ReflectionTools.GetBaseType(this System.Type type) -> System.Type
~static DryIoc.ReflectionTools.GetConstructorOrNull(this System.Type type, bool includeNonPublic = false, params System.Type[] args) -> System.Reflection.ConstructorInfo
~static DryIoc.ReflectionTools.GetConstructorOrNull(this System.Type type, params System.Type[] args) -> System.Reflection.ConstructorInfo
~static DryIoc.ReflectionTools.GetDefaultValueExpression(this System.Type type) -> FastExpressionCompiler.LightExpression.Expression
~static DryIoc.ReflectionTools.GetFieldOrNull(this System.Type type, string name, bool includeBase = false) -> System.Reflection.FieldInfo
~static DryIoc.ReflectionTools.GetGenericDefinitionOrNull(this System.Type type) -> System.Type
~static DryIoc.ReflectionTools.GetGenericParamConstraints(this System.Type type) -> System.Type[]
~static DryIoc.ReflectionTools.GetGenericParamsAndArgs(this System.Type type) -> System.Type[]
~static DryIoc.ReflectionTools.GetImplementedInterfaces(this System.Type type) -> System.Type[]
~static DryIoc.ReflectionTools.GetImplementedTypes(this System.Type sourceType, DryIoc.ReflectionTools.AsImplementedType asImplementedType = DryIoc.ReflectionTools.AsImplementedType.None) -> System.Type[]
~static DryIoc.ReflectionTools.GetLoadedTypes(this System.Reflection.Assembly assembly) -> System.Type[]
~static DryIoc.ReflectionTools.GetMembers<TMember>(this System.Type type, System.Func<System.Reflection.TypeInfo, System.Collections.Generic.IEnumerable<TMember>> getMembers, bool includeBase = false) -> System.Collections.Generic.IEnumerable<TMember>
~static DryIoc.ReflectionTools.GetMethodOrNull(this System.Type type, string name, params System.Type[] paramTypes) -> System.Reflection.MethodInfo
~static DryIoc.ReflectionTools.GetPropertyOrNull(this System.Type type, string name, bool includeBase = false) -> System.Reflection.PropertyInfo
~static DryIoc.ReflectionTools.GetReturnTypeOrDefault(this System.Reflection.MemberInfo member) -> System.Type
~static DryIoc.ReflectionTools.GetSingleConstructorOrNull(this System.Type type, bool includeNonPublic = false) -> System.Reflection.ConstructorInfo
~static DryIoc.ReflectionTools.GetSingleMethodOrNull(this System.Type type, string name, bool includeNonPublic = false) -> System.Reflection.MethodInfo
~static DryIoc.ReflectionTools.GetSourceConversionOperatorToTarget(this System.Type sourceType, System.Type targetType) -> System.Reflection.MethodInfo
~static DryIoc.ReflectionTools.GetTargetConversionOperatorFromSource(this System.Type sourceType, System.Type targetType) -> System.Reflection.MethodInfo
~static DryIoc.ReflectionTools.HasConversionOperatorTo(this System.Type sourceType, System.Type targetType) -> bool
~static DryIoc.ReflectionTools.IsAbstract(this System.Type type) -> bool
~static DryIoc.ReflectionTools.IsAssignableTo(this System.Type type, System.Type other) -> bool
~static DryIoc.ReflectionTools.IsAssignableTo<T>(this System.Type type) -> bool
~static DryIoc.ReflectionTools.IsBackingField(this System.Reflection.FieldInfo field) -> bool
~static DryIoc.ReflectionTools.IsClass(this System.Type type) -> bool
~static DryIoc.ReflectionTools.IsClosedGeneric(this System.Type type) -> bool
~static DryIoc.ReflectionTools.IsClosureType(this System.Type type) -> bool
~static DryIoc.ReflectionTools.IsCompilerGenerated(this System.Type type) -> bool
~static DryIoc.ReflectionTools.IsEnum(this System.Type type) -> bool
~static DryIoc.ReflectionTools.IsExplicitlyImplemented(this System.Reflection.PropertyInfo property) -> bool
~static DryIoc.ReflectionTools.IsGeneric(this System.Type type) -> bool
~static DryIoc.ReflectionTools.IsGenericDefinition(this System.Type type) -> bool
~static DryIoc.ReflectionTools.IsIndexer(this System.Reflection.PropertyInfo property) -> bool
~static DryIoc.ReflectionTools.IsInterface(this System.Type type) -> bool
~static DryIoc.ReflectionTools.IsOpenGeneric(this System.Type type) -> bool
~static DryIoc.ReflectionTools.IsPrimitive(this System.Type type, bool orArrayOfPrimitives = false) -> bool
~static DryIoc.ReflectionTools.IsPublicOrNestedPublic(this System.Type type) -> bool
~static DryIoc.ReflectionTools.IsStatic(this System.Reflection.MemberInfo member) -> bool
~static DryIoc.ReflectionTools.IsStatic(this System.Reflection.PropertyInfo property, bool includeNonPublic = false) -> bool
~static DryIoc.ReflectionTools.IsStatic(this System.Type type) -> bool
~static DryIoc.ReflectionTools.IsTypeOf(this System.Type type, object obj) -> bool
~static DryIoc.ReflectionTools.IsValueType(this System.Type type) -> bool
~static DryIoc.ReflectionTools.Method(this System.Type type, string name, params System.Type[] args) -> System.Reflection.MethodInfo
~static DryIoc.ReflectionTools.Property(this System.Type type, string name, bool includeBase = false) -> System.Reflection.PropertyInfo
~static DryIoc.ReflectionTools.PublicAndInternalConstructors(this System.Type type) -> System.Collections.Generic.IEnumerable<System.Reflection.ConstructorInfo>
~static DryIoc.ReflectionTools.PublicConstructors(this System.Type type) -> System.Collections.Generic.IEnumerable<System.Reflection.ConstructorInfo>
~static DryIoc.ReflectionTools.SingleConstructor(this System.Type type, bool includeNonPublic = false) -> System.Reflection.ConstructorInfo
~static DryIoc.ReflectionTools.SingleMethod(this System.Type type, string name, bool includeNonPublic = false) -> System.Reflection.MethodInfo
~static DryIoc.ReflectionTools.TryRethrowWithPreservedStackTrace(this System.Exception ex) -> void
~static DryIoc.Registrator.GetImplementationTypes(this System.Reflection.Assembly assembly) -> System.Collections.Generic.IEnumerable<System.Type>
~static DryIoc.Registrator.GetImplementationTypes(this System.Reflection.Assembly assembly, System.Func<System.Type, bool> condition) -> System.Collections.Generic.IEnumerable<System.Type>
~static DryIoc.Registrator.GetImplementedServiceTypes(this System.Type type, bool nonPublicServiceTypes = false) -> System.Type[]
~static DryIoc.Registrator.GetRegisterManyImplementedServiceTypes(this System.Type type, bool nonPublicServiceTypes = false) -> System.Type[]
~static DryIoc.Registrator.ImplementsServiceType(this System.Type type, System.Type serviceType) -> bool
~static DryIoc.Registrator.ImplementsServiceType<TService>(this System.Type type) -> bool
~static DryIoc.Registrator.Interfaces -> System.Func<System.Type, bool>
~static DryIoc.Registrator.IsExcludedGeneralPurposeServiceType(this System.Type type) -> bool
~static DryIoc.Registrator.IsImplementationType(this System.Type type) -> bool
~static DryIoc.Registrator.IsImplementingServiceType(this System.Type type, System.Type serviceType) -> bool
~static DryIoc.Registrator.IsRegistered(this DryIoc.IRegistrator registrator, System.Type serviceType, object serviceKey = null, DryIoc.FactoryType factoryType = DryIoc.FactoryType.Service, System.Func<DryIoc.Factory, bool> condition = null) -> bool
~static DryIoc.Registrator.IsRegistered<TService>(this DryIoc.IRegistrator registrator, object serviceKey = null, DryIoc.FactoryType factoryType = DryIoc.FactoryType.Service, System.Func<DryIoc.Factory, bool> condition = null) -> bool
~static DryIoc.Registrator.IsServiceType(this System.Type type) -> bool
~static DryIoc.Registrator.Register(this DryIoc.IRegistrator registrator, System.Type serviceAndMayBeImplementationType, DryIoc.IReuse reuse = null, DryIoc.Made made = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.Registrator.Register(this DryIoc.IRegistrator registrator, System.Type serviceType, DryIoc.Factory factory, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.Registrator.Register(this DryIoc.IRegistrator registrator, System.Type serviceType, System.Type implementationType, DryIoc.IReuse reuse = null, DryIoc.Made made = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.Registrator.Register<TImplementation>(this DryIoc.IRegistrator registrator, DryIoc.IReuse reuse = null, DryIoc.Made made = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.Registrator.Register<TService, TImplementation>(this DryIoc.IRegistrator registrator, DryIoc.IReuse reuse = null, DryIoc.Made made = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.Registrator.Register<TService, TMadeResult>(this DryIoc.IRegistrator registrator, DryIoc.Made.TypedMade<TMadeResult> made, DryIoc.IReuse reuse = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.Registrator.Register<TService>(this DryIoc.IRegistrator registrator, DryIoc.Made.TypedMade<TService> made, DryIoc.IReuse reuse = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterDelegate(this DryIoc.IRegistrator registrator, bool isChecked, System.Type serviceType, System.Func<DryIoc.IResolverContext, object> factoryDelegate, DryIoc.IReuse reuse = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterDelegate(this DryIoc.IRegistrator registrator, System.Type serviceType, System.Func<DryIoc.IResolverContext, object> factoryDelegate, DryIoc.IReuse reuse = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterDelegate<TDep1, TDep2, TDep3, TDep4, TDep5, TDep6, TDep7, TService>(this DryIoc.IRegistrator r, System.Func<TDep1, TDep2, TDep3, TDep4, TDep5, TDep6, TDep7, TService> factory, DryIoc.IReuse reuse = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterDelegate<TDep1, TDep2, TDep3, TDep4, TDep5, TDep6, TService>(this DryIoc.IRegistrator r, System.Func<TDep1, TDep2, TDep3, TDep4, TDep5, TDep6, TService> factory, DryIoc.IReuse reuse = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterDelegate<TDep1, TDep2, TDep3, TDep4, TDep5, TService>(this DryIoc.IRegistrator r, System.Func<TDep1, TDep2, TDep3, TDep4, TDep5, TService> factory, DryIoc.IReuse reuse = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterDelegate<TDep1, TDep2, TDep3, TDep4, TService>(this DryIoc.IRegistrator r, System.Func<TDep1, TDep2, TDep3, TDep4, TService> factory, DryIoc.IReuse reuse = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterDelegate<TDep1, TDep2, TDep3, TService>(this DryIoc.IRegistrator r, System.Func<TDep1, TDep2, TDep3, TService> factory, DryIoc.IReuse reuse = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterDelegate<TDep1, TDep2, TService>(this DryIoc.IRegistrator r, System.Func<TDep1, TDep2, TService> factory, DryIoc.IReuse reuse = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterDelegate<TDep1, TService>(this DryIoc.IRegistrator r, System.Func<TDep1, TService> factory, DryIoc.IReuse reuse = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterDelegate<TDep1>(this DryIoc.IRegistrator r, System.Type serviceType, System.Func<TDep1, object> factory, DryIoc.IReuse reuse = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterDelegate<TService>(this DryIoc.IRegistrator r, System.Func<TService> factory, DryIoc.IReuse reuse = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterDelegate<TService>(this DryIoc.IRegistrator registrator, System.Func<DryIoc.IResolverContext, TService> factoryDelegate, DryIoc.IReuse reuse = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterDelegateDecorator<TService>(this DryIoc.IRegistrator registrator, System.Func<DryIoc.IResolverContext, System.Func<TService, TService>> getDecorator, System.Func<DryIoc.Request, bool> condition = null) -> void
~static DryIoc.Registrator.RegisterDisposer<TService>(this DryIoc.IRegistrator registrator, System.Action<TService> dispose, System.Func<DryIoc.Request, bool> condition = null) -> void
~static DryIoc.Registrator.RegisterInitializer<TTarget>(this DryIoc.IRegistrator registrator, System.Action<TTarget, DryIoc.IResolverContext> initialize, System.Func<DryIoc.Request, bool> condition = null) -> void
~static DryIoc.Registrator.RegisterInstance(this DryIoc.IRegistrator registrator, bool isChecked, System.Type serviceType, object instance, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, DryIoc.Setup setup = null, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterInstance(this DryIoc.IRegistrator registrator, System.Type serviceType, object instance, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, DryIoc.Setup setup = null, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterInstance<T>(this DryIoc.IRegistrator registrator, T instance, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, DryIoc.Setup setup = null, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterInstanceMany(this DryIoc.IRegistrator registrator, System.Type implType, object instance, bool nonPublicServiceTypes = false, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, DryIoc.Setup setup = null, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterInstanceMany(this DryIoc.IRegistrator registrator, System.Type[] serviceTypes, object instance, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, DryIoc.Setup setup = null, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterInstanceMany<T>(this DryIoc.IRegistrator registrator, T instance, bool nonPublicServiceTypes = false, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, DryIoc.Setup setup = null, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterMany(this DryIoc.IRegistrator registrator, System.Collections.Generic.IEnumerable<System.Reflection.Assembly> implTypeAssemblies, System.Func<System.Type, bool> serviceTypeCondition, DryIoc.IReuse reuse = null, DryIoc.Made made = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, bool nonPublicServiceTypes = false, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterMany(this DryIoc.IRegistrator registrator, System.Collections.Generic.IEnumerable<System.Reflection.Assembly> implTypeAssemblies, System.Func<System.Type, System.Type[]> getServiceTypes, System.Func<System.Type, DryIoc.Factory> getImplFactory = null, System.Func<System.Type, System.Type, object> getServiceKey = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null) -> void
~static DryIoc.Registrator.RegisterMany(this DryIoc.IRegistrator registrator, System.Collections.Generic.IEnumerable<System.Type> implTypes, DryIoc.IReuse reuse = null, DryIoc.Made made = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, System.Func<System.Type, bool> serviceTypeCondition = null, bool nonPublicServiceTypes = false, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterMany(this DryIoc.IRegistrator registrator, System.Collections.Generic.IEnumerable<System.Type> implTypes, System.Func<System.Type, System.Type[]> getServiceTypes, System.Func<System.Type, DryIoc.Factory> getImplFactory = null, System.Func<System.Type, System.Type, object> getServiceKey = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null) -> void
~static DryIoc.Registrator.RegisterMany(this DryIoc.IRegistrator registrator, System.Type[] serviceTypes, System.Type implType, DryIoc.IReuse reuse = null, DryIoc.Made made = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterMany<TImplementation>(this DryIoc.IRegistrator registrator, DryIoc.IReuse reuse = null, DryIoc.Made made = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, System.Func<System.Type, bool> serviceTypeCondition = null, bool nonPublicServiceTypes = false, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterMany<TMadeResult>(this DryIoc.IRegistrator registrator, DryIoc.Made.TypedMade<TMadeResult> made, DryIoc.IReuse reuse = null, DryIoc.Setup setup = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, System.Func<System.Type, bool> serviceTypeCondition = null, bool nonPublicServiceTypes = false, object serviceKey = null) -> void
~static DryIoc.Registrator.RegisterManyIgnoreNoServicesWereRegistered(this DryIoc.IRegistrator registrator, System.Collections.Generic.IEnumerable<System.Type> implTypes, System.Func<System.Type, System.Type[]> getServiceTypes, System.Func<System.Type, DryIoc.Factory> getImplFactory = null, System.Func<System.Type, System.Type, object> getServiceKey = null, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null) -> void
~static DryIoc.Registrator.RegisterMapping(this DryIoc.IRegistrator registrator, System.Type serviceType, System.Type registeredServiceType, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered, object serviceKey = null, object registeredServiceKey = null, DryIoc.FactoryType factoryType = DryIoc.FactoryType.Service) -> void
~static DryIoc.Registrator.RegisterMapping(this DryIoc.IRegistrator registrator, System.Type serviceType, System.Type registeredServiceType, object serviceKey = null, object registeredServiceKey = null, DryIoc.FactoryType factoryType = DryIoc.FactoryType.Service) -> void
~static DryIoc.Registrator.RegisterMapping<TService, TRegisteredService>(this DryIoc.IContainer container, DryIoc.IfAlreadyRegistered ifAlreadyRegistered, object serviceKey = null, object registeredServiceKey = null) -> void
~static DryIoc.Registrator.RegisterMapping<TService, TRegisteredService>(this DryIoc.IRegistrator registrator, object serviceKey = null, object registeredServiceKey = null, DryIoc.FactoryType factoryType = DryIoc.FactoryType.Service) -> void
~static DryIoc.Registrator.RegisterPlaceholder(this DryIoc.IRegistrator registrator, System.Type serviceType, DryIoc.IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) -> void
~static DryIoc.Registrator.ToFactory(this System.Type implType) -> DryIoc.Factory
~static DryIoc.Registrator.ToFactory(this System.Type implType, DryIoc.IReuse reuse, DryIoc.Made made = null, DryIoc.Setup setup = null) -> DryIoc.Factory
~static DryIoc.Registrator.ToFactoryDelegate(this object result, DryIoc.IResolverContext _) -> object
~static DryIoc.Registrator.ToFactoryDelegate<TService>(this System.Func<DryIoc.IResolverContext, TService> f, DryIoc.IResolverContext r) -> object
~static DryIoc.Registrator.Unregister(this DryIoc.IRegistrator registrator, System.Type serviceType, object serviceKey = null, DryIoc.FactoryType factoryType = DryIoc.FactoryType.Service, System.Func<DryIoc.Factory, bool> condition = null) -> void
~static DryIoc.Registrator.Unregister<TService>(this DryIoc.IRegistrator registrator, object serviceKey = null, DryIoc.FactoryType factoryType = DryIoc.FactoryType.Service, System.Func<DryIoc.Factory, bool> condition = null) -> void
~static DryIoc.Registrator.Use(this DryIoc.IContainer c, System.Type serviceType, object instance) -> void
~static DryIoc.Registrator.Use(this DryIoc.IRegistrator r, System.Type serviceType, object instance) -> void
~static DryIoc.Registrator.Use(this DryIoc.IResolverContext r, System.Type serviceType, object instance) -> void
~static DryIoc.Registrator.Use<TService>(this DryIoc.IContainer c, System.Func<DryIoc.IResolverContext, TService> factory) -> void
~static DryIoc.Registrator.Use<TService>(this DryIoc.IContainer c, TService instance) -> void
~static DryIoc.Registrator.Use<TService>(this DryIoc.IRegistrator r, System.Func<DryIoc.IResolverContext, TService> factory) -> void
~static DryIoc.Registrator.Use<TService>(this DryIoc.IRegistrator r, TService instance) -> void
~static DryIoc.Registrator.Use<TService>(this DryIoc.IResolverContext r, System.Func<DryIoc.IResolverContext, TService> factory) -> void
~static DryIoc.Registrator.Use<TService>(this DryIoc.IResolverContext r, TService instance) -> void
~static DryIoc.Registrator.UseInstance(this DryIoc.IContainer c, System.Type serviceType, object instance, bool preventDisposal = false, bool weaklyReferenced = false, object serviceKey = null) -> void
~static DryIoc.Registrator.UseInstance(this DryIoc.IContainer c, System.Type serviceType, object instance, DryIoc.IfAlreadyRegistered ifAlreadyRegistered, bool preventDisposal = false, bool weaklyReferenced = false, object serviceKey = null) -> void
~static DryIoc.Registrator.UseInstance(this DryIoc.IRegistrator r, System.Type serviceType, object instance, bool preventDisposal = false, bool weaklyReferenced = false, object serviceKey = null) -> void
~static DryIoc.Registrator.UseInstance(this DryIoc.IRegistrator r, System.Type serviceType, object instance, DryIoc.IfAlreadyRegistered ifAlreadyRegistered, bool preventDisposal = false, bool weaklyReferenced = false, object serviceKey = null) -> void
~static DryIoc.Registrator.UseInstance(this DryIoc.IResolverContext r, System.Type serviceType, object instance, bool preventDisposal = false, bool weaklyReferenced = false, object serviceKey = null) -> void
~static DryIoc.Registrator.UseInstance(this DryIoc.IResolverContext r, System.Type serviceType, object instance, DryIoc.IfAlreadyRegistered ifAlreadyRegistered, bool preventDisposal = false, bool weaklyReferenced = false, object serviceKey = null) -> void
~static DryIoc.Registrator.UseInstance<TService>(this DryIoc.IContainer c, TService instance, bool preventDisposal = false, bool weaklyReferenced = false, object serviceKey = null) -> void
~static DryIoc.Registrator.UseInstance<TService>(this DryIoc.IRegistrator r, TService instance, bool preventDisposal = false, bool weaklyReferenced = false, object serviceKey = null) -> void
~static DryIoc.Registrator.UseInstance<TService>(this DryIoc.IResolverContext r, TService instance, bool preventDisposal = false, bool weaklyReferenced = false, object serviceKey = null) -> void
~static DryIoc.Registrator.UseInstance<TService>(this DryIoc.IResolverContext r, TService instance, DryIoc.IfAlreadyRegistered ifAlreadyRegistered, bool preventDisposal = false, bool weaklyReferenced = false, object serviceKey = null) -> void
~static DryIoc.Request.Create(DryIoc.IContainer container, DryIoc.IServiceInfo serviceInfo, DryIoc.Request preResolveParent = null, DryIoc.RequestFlags flags = (DryIoc.RequestFlags)0, object[] inputArgs = null) -> DryIoc.Request
~static DryIoc.Request.Create(DryIoc.IContainer container, System.Type serviceType, object serviceKey = null, DryIoc.IfUnresolved ifUnresolved = DryIoc.IfUnresolved.Throw, System.Type requiredServiceType = null, DryIoc.Request preResolveParent = null, DryIoc.RequestFlags flags = (DryIoc.RequestFlags)0, object[] inputArgs = null) -> DryIoc.Request
~static DryIoc.ResolutionScopeName.Of(System.Type serviceType = null, object serviceKey = null) -> DryIoc.ResolutionScopeName
~static DryIoc.ResolutionScopeName.Of<TService>(object serviceKey = null) -> DryIoc.ResolutionScopeName
~static DryIoc.Resolver.Resolve(this DryIoc.IResolver resolver, System.Type serviceType) -> object
~static DryIoc.Resolver.Resolve(this DryIoc.IResolver resolver, System.Type serviceType, bool ifUnresolvedReturnDefault) -> object
~static DryIoc.Resolver.Resolve(this DryIoc.IResolver resolver, System.Type serviceType, DryIoc.IfUnresolved ifUnresolved) -> object
~static DryIoc.Resolver.Resolve(this DryIoc.IResolver resolver, System.Type serviceType, object serviceKey, DryIoc.IfUnresolved ifUnresolved = DryIoc.IfUnresolved.Throw, System.Type requiredServiceType = null, object[] args = null) -> object
~static DryIoc.Resolver.Resolve(this DryIoc.IResolver resolver, System.Type serviceType, object[] args, DryIoc.IfUnresolved ifUnresolved = DryIoc.IfUnresolved.Throw, System.Type requiredServiceType = null, object serviceKey = null) -> object
~static DryIoc.Resolver.Resolve(this DryIoc.IResolver resolver, System.Type serviceType, System.Type requiredServiceType, DryIoc.IfUnresolved ifUnresolved = DryIoc.IfUnresolved.Throw, object[] args = null, object serviceKey = null) -> object
~static DryIoc.Resolver.Resolve<TService, TRequiredService>(this DryIoc.IResolver resolver, DryIoc.IfUnresolved ifUnresolved = DryIoc.IfUnresolved.Throw, object[] args = null, object serviceKey = null) -> TService
~static DryIoc.Resolver.Resolve<TService>(this DryIoc.IResolver resolver, bool ifUnresolvedReturnDefault) -> object
~static DryIoc.Resolver.Resolve<TService>(this DryIoc.IResolver resolver, DryIoc.IfUnresolved ifUnresolved = DryIoc.IfUnresolved.Throw) -> TService
~static DryIoc.Resolver.Resolve<TService>(this DryIoc.IResolver resolver, object serviceKey, DryIoc.IfUnresolved ifUnresolved = DryIoc.IfUnresolved.Throw, System.Type requiredServiceType = null, object[] args = null) -> TService
~static DryIoc.Resolver.Resolve<TService>(this DryIoc.IResolver resolver, object[] args, DryIoc.IfUnresolved ifUnresolved = DryIoc.IfUnresolved.Throw, System.Type requiredServiceType = null, object serviceKey = null) -> TService
~static DryIoc.Resolver.Resolve<TService>(this DryIoc.IResolver resolver, System.Type requiredServiceType, DryIoc.IfUnresolved ifUnresolved = DryIoc.IfUnresolved.Throw, object[] args = null, object serviceKey = null) -> TService
~static DryIoc.Resolver.ResolveMany(this DryIoc.IResolver resolver, System.Type serviceType, DryIoc.ResolveManyBehavior behavior = DryIoc.ResolveManyBehavior.AsLazyEnumerable, object[] args = null, object serviceKey = null) -> System.Collections.Generic.IEnumerable<object>
~static DryIoc.Resolver.ResolveMany<TService>(this DryIoc.IResolver resolver, System.Type requiredServiceType = null, DryIoc.ResolveManyBehavior behavior = DryIoc.ResolveManyBehavior.AsLazyEnumerable, object[] args = null, object serviceKey = null) -> System.Collections.Generic.IEnumerable<TService>
~static DryIoc.ResolverContext.GetCurrentScope(this DryIoc.IResolverContext r, bool throwIfNotFound) -> DryIoc.IScope
~static DryIoc.ResolverContext.GetNamedScope(this DryIoc.IResolverContext r, object name, bool throwIfNotFound) -> DryIoc.IScope
~static DryIoc.ResolverContext.GetRootOrSelfExpr(DryIoc.Request request) -> FastExpressionCompiler.LightExpression.Expression
~static DryIoc.ResolverContext.IsScoped(this DryIoc.IResolverContext r) -> bool
~static DryIoc.ResolverContext.OpenScope(this DryIoc.IResolverContext r, object name = null, bool trackInParent = false) -> DryIoc.IResolverContext
~static DryIoc.ResolverContext.RootOrSelf(this DryIoc.IResolverContext r) -> DryIoc.IResolverContext
~static DryIoc.ResolverContext.TrackDisposable<T>(this DryIoc.IResolverContext r, T instance) -> T
~static DryIoc.Reuse.InCurrentNamedScope(object name = null) -> DryIoc.IReuse
~static DryIoc.Reuse.InResolutionScopeOf(System.Type assignableFromServiceType = null, object serviceKey = null) -> DryIoc.IReuse
~static DryIoc.Reuse.InResolutionScopeOf<TAssignableFromServiceType>(object serviceKey = null) -> DryIoc.IReuse
~static DryIoc.Reuse.ScopedTo(object name) -> DryIoc.IReuse
~static DryIoc.Reuse.ScopedTo(object name, bool scopedOrSingleton, int lifespan) -> DryIoc.IReuse
~static DryIoc.Reuse.ScopedTo(params object[] names) -> DryIoc.IReuse
~static DryIoc.Reuse.ScopedTo(System.Type serviceType = null, object serviceKey = null) -> DryIoc.IReuse
~static DryIoc.Reuse.ScopedTo<TService>(object serviceKey = null) -> DryIoc.IReuse
~static DryIoc.Reuse.WebRequestScopeName -> string
~static DryIoc.Rules.AutoFallbackDynamicRegistrations(System.Func<System.Type, object, System.Collections.Generic.IEnumerable<System.Type>> getImplementationTypes, System.Func<System.Type, DryIoc.Factory> factory = null) -> DryIoc.Rules.DynamicRegistrationProvider
~static DryIoc.Rules.AutoRegisterUnknownServiceRule(System.Collections.Generic.IEnumerable<System.Type> implTypes, System.Func<DryIoc.IReuse, DryIoc.Request, DryIoc.IReuse> changeDefaultReuse = null, System.Func<DryIoc.Request, bool> condition = null) -> DryIoc.Rules.UnknownServiceResolver
~static DryIoc.Rules.AutoResolveConcreteTypeRule(System.Func<DryIoc.Request, bool> condition = null) -> DryIoc.Rules.UnknownServiceResolver
~static DryIoc.Rules.ConcreteTypeDynamicRegistrations(System.Func<System.Type, object, bool> condition = null, DryIoc.IReuse reuse = null) -> DryIoc.Rules.DynamicRegistrationProvider
~static DryIoc.Rules.SelectKeyedOverDefaultFactory(object serviceKey) -> DryIoc.Rules.FactorySelectorRule
~static DryIoc.Rules.SelectLastRegisteredFactory() -> DryIoc.Rules.FactorySelectorRule
~static DryIoc.ServiceDetails.Of(object value) -> DryIoc.ServiceDetails
~static DryIoc.ServiceDetails.Of(System.Type requiredServiceType = null, object serviceKey = null, DryIoc.IfUnresolved ifUnresolved = DryIoc.IfUnresolved.Throw, object defaultValue = null, string metadataKey = null, object metadata = null) -> DryIoc.ServiceDetails
~static DryIoc.ServiceInfo.Of(System.Type serviceType, DryIoc.IfUnresolved ifUnresolved = DryIoc.IfUnresolved.Throw, object serviceKey = null) -> DryIoc.ServiceInfo
~static DryIoc.ServiceInfo.Of(System.Type serviceType, System.Type requiredServiceType, DryIoc.IfUnresolved ifUnresolved = DryIoc.IfUnresolved.Throw, object serviceKey = null, string metadataKey = null, object metadata = null) -> DryIoc.ServiceInfo
~static DryIoc.ServiceInfo.Of<TService>(DryIoc.IfUnresolved ifUnresolved = DryIoc.IfUnresolved.Throw, object serviceKey = null) -> DryIoc.ServiceInfo.Typed<TService>
~static DryIoc.ServiceInfoTools.GetActualServiceType(this DryIoc.IServiceInfo info) -> System.Type
~static DryIoc.ServiceInfoTools.InheritInfoFromDependencyOwner(this DryIoc.IServiceInfo dependency, DryIoc.IServiceInfo owner, DryIoc.IContainer container, DryIoc.FactoryType ownerType = DryIoc.FactoryType.Service) -> DryIoc.IServiceInfo
~static DryIoc.ServiceInfoTools.Print(this System.Text.StringBuilder s, DryIoc.IServiceInfo info) -> System.Text.StringBuilder
~static DryIoc.ServiceInfoTools.With(this DryIoc.IServiceInfo source, System.Type serviceType) -> DryIoc.IServiceInfo
~static DryIoc.ServiceInfoTools.WithDetails<T>(this T serviceInfo, DryIoc.ServiceDetails details) -> T
~static DryIoc.ServiceInfoTools.WithIfUnresolved(this DryIoc.IServiceInfo source, DryIoc.IfUnresolved ifUnresolved) -> DryIoc.IServiceInfo
~static DryIoc.Setup.DecoratorOf(System.Type decorateeType = null, int order = 0, bool useDecorateeReuse = false, bool openResolutionScope = false, bool asResolutionCall = false, bool preventDisposal = false, bool weaklyReferenced = false, bool allowDisposableTransient = false, bool trackDisposableTransient = false, int disposalOrder = 0, object decorateeServiceKey = null) -> DryIoc.Setup
~static DryIoc.Setup.DecoratorOf<TDecoratee>(int order = 0, bool useDecorateeReuse = false, bool openResolutionScope = false, bool asResolutionCall = false, bool preventDisposal = false, bool weaklyReferenced = false, bool allowDisposableTransient = false, bool trackDisposableTransient = false, int disposalOrder = 0, object decorateeServiceKey = null) -> DryIoc.Setup
~static DryIoc.Setup.DecoratorWith(System.Func<DryIoc.Request, bool> condition = null, int order = 0, bool useDecorateeReuse = false, bool openResolutionScope = false, bool asResolutionCall = false, bool preventDisposal = false, bool weaklyReferenced = false, bool allowDisposableTransient = false, bool trackDisposableTransient = false, int disposalOrder = 0) -> DryIoc.Setup
~static DryIoc.Setup.GetDecorateeCondition(System.Type decorateeType, object decorateeServiceKey = null, System.Func<DryIoc.Request, bool> condition = null) -> System.Func<DryIoc.Request, bool>
~static DryIoc.Setup.With(object metadataOrFuncOfMetadata = null, System.Func<DryIoc.Request, bool> condition = null, bool openResolutionScope = false, bool asResolutionCall = false, bool asResolutionRoot = false, bool preventDisposal = false, bool weaklyReferenced = false, bool allowDisposableTransient = false, bool trackDisposableTransient = false, bool useParentReuse = false, int disposalOrder = 0, bool preferInSingleServiceResolve = false) -> DryIoc.Setup
~static DryIoc.Setup.WrapperWith(int wrappedServiceTypeArgIndex = -1, bool alwaysWrapsRequiredServiceType = false, System.Func<System.Type, System.Type> unwrap = null, bool openResolutionScope = false, bool asResolutionCall = false, bool preventDisposal = false, bool weaklyReferenced = false, bool allowDisposableTransient = false, bool trackDisposableTransient = false, bool useParentReuse = false, System.Func<DryIoc.Request, bool> condition = null, int disposalOrder = 0) -> DryIoc.Setup
~static DryIoc.Throw.For<T>(bool throwCondition, int error, object arg0 = null, object arg1 = null, object arg2 = null, object arg3 = null) -> T
~static DryIoc.Throw.For<T>(int error, object arg0 = null, object arg1 = null, object arg2 = null, object arg3 = null) -> T
~static DryIoc.Throw.GetDefaultMessage(DryIoc.ErrorCheck error) -> string
~static DryIoc.Throw.GetMatchedException -> DryIoc.Throw.GetMatchedExceptionHandler
~static DryIoc.Throw.If(bool throwCondition, int error = -1, object arg0 = null, object arg1 = null, object arg2 = null, object arg3 = null) -> void
~static DryIoc.Throw.IfThrows<TEx, T>(System.Func<T> operation, bool throwCondition, int error, object arg0 = null, object arg1 = null, object arg2 = null, object arg3 = null) -> T
~static DryIoc.Throw.It(int error, object arg0 = null, object arg1 = null, object arg2 = null, object arg3 = null) -> object
~static DryIoc.Throw.ThrowIf<T>(this T arg0, bool throwCondition, int error = -1, object arg1 = null, object arg2 = null, object arg3 = null) -> T
~static DryIoc.Throw.ThrowIfNotImplementedBy(this System.Type arg0, System.Type arg1, int error = -1, object arg2 = null, object arg3 = null) -> System.Type
~static DryIoc.Throw.ThrowIfNotInstanceOf<T>(this T arg0, System.Type arg1, int error = -1, object arg2 = null, object arg3 = null) -> T
~static DryIoc.Throw.ThrowIfNull<T>(this T arg, int error = -1, object arg0 = null, object arg1 = null, object arg2 = null, object arg3 = null) -> T
~static DryIoc.ThrowInGeneratedCode.WeakRefReuseWrapperGCed(this object obj) -> object
~static DryIoc.WrappersSupport.GetLazyExpressionOrDefault(DryIoc.Request request, bool nullWrapperForUnresolvedService = false) -> FastExpressionCompiler.LightExpression.Expression
~static DryIoc.WrappersSupport.GetMetaExpressionOrDefault(DryIoc.Request request) -> FastExpressionCompiler.LightExpression.Expression
~static DryIoc.WrappersSupport.IsFunc(this System.Type type) -> bool
~static FastExpressionCompiler.LightExpression.CodePrinter.AppendTypeof(this System.Text.StringBuilder sb, System.Type type, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null) -> System.Text.StringBuilder
~static FastExpressionCompiler.LightExpression.CodePrinter.ToArrayInitializerCode(this System.Collections.IEnumerable items, System.Type itemType, FastExpressionCompiler.LightExpression.CodePrinter.IObjectToCode notRecognizedToCode, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null) -> string
~static FastExpressionCompiler.LightExpression.CodePrinter.ToCode(this bool x) -> string
~static FastExpressionCompiler.LightExpression.CodePrinter.ToCode(this object x, FastExpressionCompiler.LightExpression.CodePrinter.IObjectToCode notRecognizedToCode, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null) -> string
~static FastExpressionCompiler.LightExpression.CodePrinter.ToCode(this string x) -> string
~static FastExpressionCompiler.LightExpression.CodePrinter.ToCode(this System.Type type, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null) -> string
~static FastExpressionCompiler.LightExpression.CodePrinter.ToCommaSeparatedCode(this System.Collections.IEnumerable items, FastExpressionCompiler.LightExpression.CodePrinter.IObjectToCode notRecognizedToCode, bool stripNamespace = false, System.Func<System.Type, string, string> printType = null) -> string
~static FastExpressionCompiler.LightExpression.CodePrinter.ToEnumValueCode(this System.Type enumType, object x) -> string
~static FastExpressionCompiler.LightExpression.ConstantExpression.ValueToCode -> FastExpressionCompiler.LightExpression.CodePrinter.IObjectToCode
~static FastExpressionCompiler.LightExpression.Expression.Add(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.AddAssign(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.AddAssignChecked(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.AddChecked(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.And(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.AndAlso(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.AndAssign(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.ArrayAccess(FastExpressionCompiler.LightExpression.Expression array, params FastExpressionCompiler.LightExpression.Expression[] indexes) -> FastExpressionCompiler.LightExpression.IndexExpression
~static FastExpressionCompiler.LightExpression.Expression.ArrayAccess(FastExpressionCompiler.LightExpression.Expression array, System.Collections.Generic.IEnumerable<FastExpressionCompiler.LightExpression.Expression> indexes) -> FastExpressionCompiler.LightExpression.IndexExpression
~static FastExpressionCompiler.LightExpression.Expression.ArrayIndex(FastExpressionCompiler.LightExpression.Expression array, FastExpressionCompiler.LightExpression.Expression index) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.ArrayLength(FastExpressionCompiler.LightExpression.Expression array) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Assign(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Bind(System.Reflection.MemberInfo member, FastExpressionCompiler.LightExpression.Expression expression) -> FastExpressionCompiler.LightExpression.MemberAssignment
~static FastExpressionCompiler.LightExpression.Expression.Block(FastExpressionCompiler.LightExpression.ParameterExpression variable, FastExpressionCompiler.LightExpression.Expression expression1, FastExpressionCompiler.LightExpression.Expression expression2) -> FastExpressionCompiler.LightExpression.Expression
~static FastExpressionCompiler.LightExpression.Expression.Block(params FastExpressionCompiler.LightExpression.Expression[] expressions) -> FastExpressionCompiler.LightExpression.BlockExpression
~static FastExpressionCompiler.LightExpression.Expression.Block(System.Collections.Generic.IEnumerable<FastExpressionCompiler.LightExpression.ParameterExpression> variables, params FastExpressionCompiler.LightExpression.Expression[] expressions) -> FastExpressionCompiler.LightExpression.BlockExpression
~static FastExpressionCompiler.LightExpression.Expression.Block(System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.Expression> expressions) -> FastExpressionCompiler.LightExpression.BlockExpression
~static FastExpressionCompiler.LightExpression.Expression.Block(System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.ParameterExpression> variables, System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.Expression> expressions) -> FastExpressionCompiler.LightExpression.BlockExpression
~static FastExpressionCompiler.LightExpression.Expression.Block(System.Type type, System.Collections.Generic.IEnumerable<FastExpressionCompiler.LightExpression.ParameterExpression> variables, params FastExpressionCompiler.LightExpression.Expression[] expressions) -> FastExpressionCompiler.LightExpression.BlockExpression
~static FastExpressionCompiler.LightExpression.Expression.Block(System.Type type, System.Collections.Generic.IEnumerable<FastExpressionCompiler.LightExpression.ParameterExpression> variables, System.Collections.Generic.IEnumerable<FastExpressionCompiler.LightExpression.Expression> expressions) -> FastExpressionCompiler.LightExpression.BlockExpression
~static FastExpressionCompiler.LightExpression.Expression.Break(System.Linq.Expressions.LabelTarget target, FastExpressionCompiler.LightExpression.Expression value = null, System.Type type = null) -> FastExpressionCompiler.LightExpression.GotoExpression
~static FastExpressionCompiler.LightExpression.Expression.Call(FastExpressionCompiler.LightExpression.Expression instance, string methodName, System.Type[] typeArguments, params FastExpressionCompiler.LightExpression.Expression[] arguments) -> FastExpressionCompiler.LightExpression.MethodCallExpression
~static FastExpressionCompiler.LightExpression.Expression.Call(FastExpressionCompiler.LightExpression.Expression instance, string methodName, System.Type[] typeArguments, System.Collections.Generic.IEnumerable<FastExpressionCompiler.LightExpression.Expression> arguments) -> FastExpressionCompiler.LightExpression.MethodCallExpression
~static FastExpressionCompiler.LightExpression.Expression.Call(FastExpressionCompiler.LightExpression.Expression instance, System.Reflection.MethodInfo method) -> FastExpressionCompiler.LightExpression.MethodCallExpression
~static FastExpressionCompiler.LightExpression.Expression.Call(FastExpressionCompiler.LightExpression.Expression instance, System.Reflection.MethodInfo method, FastExpressionCompiler.LightExpression.Expression arg0, FastExpressionCompiler.LightExpression.Expression arg1) -> FastExpressionCompiler.LightExpression.MethodCallExpression
~static FastExpressionCompiler.LightExpression.Expression.Call(FastExpressionCompiler.LightExpression.Expression instance, System.Reflection.MethodInfo method, FastExpressionCompiler.LightExpression.Expression arg0, FastExpressionCompiler.LightExpression.Expression arg1, FastExpressionCompiler.LightExpression.Expression arg2) -> FastExpressionCompiler.LightExpression.MethodCallExpression
~static FastExpressionCompiler.LightExpression.Expression.Call(FastExpressionCompiler.LightExpression.Expression instance, System.Reflection.MethodInfo method, FastExpressionCompiler.LightExpression.Expression arg0, FastExpressionCompiler.LightExpression.Expression arg1, FastExpressionCompiler.LightExpression.Expression arg2, FastExpressionCompiler.LightExpression.Expression arg3) -> FastExpressionCompiler.LightExpression.MethodCallExpression
~static FastExpressionCompiler.LightExpression.Expression.Call(FastExpressionCompiler.LightExpression.Expression instance, System.Reflection.MethodInfo method, FastExpressionCompiler.LightExpression.Expression arg0, FastExpressionCompiler.LightExpression.Expression arg1, FastExpressionCompiler.LightExpression.Expression arg2, FastExpressionCompiler.LightExpression.Expression arg3, FastExpressionCompiler.LightExpression.Expression arg4) -> FastExpressionCompiler.LightExpression.MethodCallExpression
~static FastExpressionCompiler.LightExpression.Expression.Call(FastExpressionCompiler.LightExpression.Expression instance, System.Reflection.MethodInfo method, FastExpressionCompiler.LightExpression.Expression argument) -> FastExpressionCompiler.LightExpression.MethodCallExpression
~static FastExpressionCompiler.LightExpression.Expression.Call(FastExpressionCompiler.LightExpression.Expression instance, System.Reflection.MethodInfo method, params FastExpressionCompiler.LightExpression.Expression[] arguments) -> FastExpressionCompiler.LightExpression.MethodCallExpression
~static FastExpressionCompiler.LightExpression.Expression.Call(FastExpressionCompiler.LightExpression.Expression instance, System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable<FastExpressionCompiler.LightExpression.Expression> arguments) -> FastExpressionCompiler.LightExpression.MethodCallExpression
~static FastExpressionCompiler.LightExpression.Expression.Call(System.Reflection.MethodInfo method) -> FastExpressionCompiler.LightExpression.MethodCallExpression
~static FastExpressionCompiler.LightExpression.Expression.Call(System.Reflection.MethodInfo method, FastExpressionCompiler.LightExpression.Expression arg0, FastExpressionCompiler.LightExpression.Expression arg1) -> FastExpressionCompiler.LightExpression.MethodCallExpression
~static FastExpressionCompiler.LightExpression.Expression.Call(System.Reflection.MethodInfo method, FastExpressionCompiler.LightExpression.Expression arg0, FastExpressionCompiler.LightExpression.Expression arg1, FastExpressionCompiler.LightExpression.Expression arg2) -> FastExpressionCompiler.LightExpression.MethodCallExpression
~static FastExpressionCompiler.LightExpression.Expression.Call(System.Reflection.MethodInfo method, FastExpressionCompiler.LightExpression.Expression arg0, FastExpressionCompiler.LightExpression.Expression arg1, FastExpressionCompiler.LightExpression.Expression arg2, FastExpressionCompiler.LightExpression.Expression arg3) -> FastExpressionCompiler.LightExpression.MethodCallExpression
~static FastExpressionCompiler.LightExpression.Expression.Call(System.Reflection.MethodInfo method, FastExpressionCompiler.LightExpression.Expression arg0, FastExpressionCompiler.LightExpression.Expression arg1, FastExpressionCompiler.LightExpression.Expression arg2, FastExpressionCompiler.LightExpression.Expression arg3, FastExpressionCompiler.LightExpression.Expression arg4) -> FastExpressionCompiler.LightExpression.MethodCallExpression
~static FastExpressionCompiler.LightExpression.Expression.Call(System.Reflection.MethodInfo method, FastExpressionCompiler.LightExpression.Expression argument) -> FastExpressionCompiler.LightExpression.MethodCallExpression
~static FastExpressionCompiler.LightExpression.Expression.Call(System.Reflection.MethodInfo method, params FastExpressionCompiler.LightExpression.Expression[] arguments) -> FastExpressionCompiler.LightExpression.MethodCallExpression
~static FastExpressionCompiler.LightExpression.Expression.Call(System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable<FastExpressionCompiler.LightExpression.Expression> arguments) -> FastExpressionCompiler.LightExpression.MethodCallExpression
~static FastExpressionCompiler.LightExpression.Expression.Call(System.Type type, string methodName, System.Type[] typeArguments, params FastExpressionCompiler.LightExpression.Expression[] arguments) -> FastExpressionCompiler.LightExpression.MethodCallExpression
~static FastExpressionCompiler.LightExpression.Expression.Call(System.Type type, string methodName, System.Type[] typeArguments, System.Collections.Generic.IEnumerable<FastExpressionCompiler.LightExpression.Expression> arguments) -> FastExpressionCompiler.LightExpression.MethodCallExpression
~static FastExpressionCompiler.LightExpression.Expression.CallIfNotNull(FastExpressionCompiler.LightExpression.Expression instance, System.Reflection.MethodInfo method) -> FastExpressionCompiler.LightExpression.Expression
~static FastExpressionCompiler.LightExpression.Expression.CallIfNotNull(FastExpressionCompiler.LightExpression.Expression instance, System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable<FastExpressionCompiler.LightExpression.Expression> arguments) -> FastExpressionCompiler.LightExpression.Expression
~static FastExpressionCompiler.LightExpression.Expression.Catch(FastExpressionCompiler.LightExpression.ParameterExpression variable, FastExpressionCompiler.LightExpression.Expression body) -> FastExpressionCompiler.LightExpression.CatchBlock
~static FastExpressionCompiler.LightExpression.Expression.Catch(System.Type test, FastExpressionCompiler.LightExpression.Expression body) -> FastExpressionCompiler.LightExpression.CatchBlock
~static FastExpressionCompiler.LightExpression.Expression.Coalesce(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Coalesce(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right, FastExpressionCompiler.LightExpression.LambdaExpression conversion) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Coalesce(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right, System.Type type) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Condition(FastExpressionCompiler.LightExpression.Expression test, FastExpressionCompiler.LightExpression.Expression ifTrue, FastExpressionCompiler.LightExpression.Expression ifFalse) -> FastExpressionCompiler.LightExpression.ConditionalExpression
~static FastExpressionCompiler.LightExpression.Expression.Condition(FastExpressionCompiler.LightExpression.Expression test, FastExpressionCompiler.LightExpression.Expression ifTrue, FastExpressionCompiler.LightExpression.Expression ifFalse, System.Type type) -> FastExpressionCompiler.LightExpression.ConditionalExpression
~static FastExpressionCompiler.LightExpression.Expression.Constant(bool value) -> FastExpressionCompiler.LightExpression.ConstantExpression
~static FastExpressionCompiler.LightExpression.Expression.Constant(int value) -> FastExpressionCompiler.LightExpression.ConstantExpression
~static FastExpressionCompiler.LightExpression.Expression.Constant(object value) -> FastExpressionCompiler.LightExpression.ConstantExpression
~static FastExpressionCompiler.LightExpression.Expression.Constant(object value, System.Type type) -> FastExpressionCompiler.LightExpression.ConstantExpression
~static FastExpressionCompiler.LightExpression.Expression.Constant<T>(T value) -> FastExpressionCompiler.LightExpression.ConstantExpression
~static FastExpressionCompiler.LightExpression.Expression.Continue(System.Linq.Expressions.LabelTarget target, System.Type type = null) -> FastExpressionCompiler.LightExpression.GotoExpression
~static FastExpressionCompiler.LightExpression.Expression.Convert(FastExpressionCompiler.LightExpression.Expression expression, System.Type type) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Convert(FastExpressionCompiler.LightExpression.Expression expression, System.Type type, System.Reflection.MethodInfo method) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Convert<TTo>(FastExpressionCompiler.LightExpression.Expression expression) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.ConvertChecked(FastExpressionCompiler.LightExpression.Expression expression, System.Type type) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.ConvertChecked(FastExpressionCompiler.LightExpression.Expression expression, System.Type type, System.Reflection.MethodInfo method) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Decrement(FastExpressionCompiler.LightExpression.Expression expression) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Default(System.Type type) -> FastExpressionCompiler.LightExpression.DefaultExpression
~static FastExpressionCompiler.LightExpression.Expression.Divide(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.DivideAssign(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Empty() -> FastExpressionCompiler.LightExpression.DefaultExpression
~static FastExpressionCompiler.LightExpression.Expression.Equal(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.ExclusiveOr(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.ExclusiveOrAssign(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Field(FastExpressionCompiler.LightExpression.Expression instance, string fieldName) -> FastExpressionCompiler.LightExpression.MemberExpression
~static FastExpressionCompiler.LightExpression.Expression.Field(FastExpressionCompiler.LightExpression.Expression instance, System.Reflection.FieldInfo field) -> FastExpressionCompiler.LightExpression.MemberExpression
~static FastExpressionCompiler.LightExpression.Expression.Field(System.Reflection.FieldInfo field) -> FastExpressionCompiler.LightExpression.MemberExpression
~static FastExpressionCompiler.LightExpression.Expression.Goto(System.Linq.Expressions.LabelTarget target, FastExpressionCompiler.LightExpression.Expression value = null, System.Type type = null) -> FastExpressionCompiler.LightExpression.GotoExpression
~static FastExpressionCompiler.LightExpression.Expression.GreaterThan(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.GreaterThanOrEqual(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.IfThen(FastExpressionCompiler.LightExpression.Expression test, FastExpressionCompiler.LightExpression.Expression ifTrue) -> FastExpressionCompiler.LightExpression.ConditionalExpression
~static FastExpressionCompiler.LightExpression.Expression.IfThenElse(FastExpressionCompiler.LightExpression.Expression test, FastExpressionCompiler.LightExpression.Expression ifTrue, FastExpressionCompiler.LightExpression.Expression ifFalse) -> FastExpressionCompiler.LightExpression.ConditionalExpression
~static FastExpressionCompiler.LightExpression.Expression.Increment(FastExpressionCompiler.LightExpression.Expression expression) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Invoke(FastExpressionCompiler.LightExpression.Expression expression, FastExpressionCompiler.LightExpression.Expression arg0) -> FastExpressionCompiler.LightExpression.InvocationExpression
~static FastExpressionCompiler.LightExpression.Expression.Invoke(FastExpressionCompiler.LightExpression.Expression expression, System.Collections.Generic.IEnumerable<FastExpressionCompiler.LightExpression.Expression> args) -> FastExpressionCompiler.LightExpression.InvocationExpression
~static FastExpressionCompiler.LightExpression.Expression.Invoke(FastExpressionCompiler.LightExpression.Expression lambda, params FastExpressionCompiler.LightExpression.Expression[] args) -> FastExpressionCompiler.LightExpression.InvocationExpression
~static FastExpressionCompiler.LightExpression.Expression.Invoke(FastExpressionCompiler.LightExpression.LambdaExpression expression, FastExpressionCompiler.LightExpression.Expression arg0) -> FastExpressionCompiler.LightExpression.InvocationExpression
~static FastExpressionCompiler.LightExpression.Expression.IsFalse(FastExpressionCompiler.LightExpression.Expression expression) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.IsTrue(FastExpressionCompiler.LightExpression.Expression expression) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Label(string name) -> System.Linq.Expressions.LabelTarget
~static FastExpressionCompiler.LightExpression.Expression.Label(System.Linq.Expressions.LabelTarget target, FastExpressionCompiler.LightExpression.Expression defaultValue = null) -> FastExpressionCompiler.LightExpression.LabelExpression
~static FastExpressionCompiler.LightExpression.Expression.Label(System.Type type = null, string name = null) -> System.Linq.Expressions.LabelTarget
~static FastExpressionCompiler.LightExpression.Expression.Lambda(FastExpressionCompiler.LightExpression.Expression body) -> FastExpressionCompiler.LightExpression.LambdaExpression
~static FastExpressionCompiler.LightExpression.Expression.Lambda(FastExpressionCompiler.LightExpression.Expression body, params FastExpressionCompiler.LightExpression.ParameterExpression[] parameters) -> FastExpressionCompiler.LightExpression.LambdaExpression
~static FastExpressionCompiler.LightExpression.Expression.Lambda(System.Type delegateType, FastExpressionCompiler.LightExpression.Expression body) -> FastExpressionCompiler.LightExpression.LambdaExpression
~static FastExpressionCompiler.LightExpression.Expression.Lambda(System.Type delegateType, FastExpressionCompiler.LightExpression.Expression body, FastExpressionCompiler.LightExpression.ParameterExpression[] parameters, System.Type returnType) -> FastExpressionCompiler.LightExpression.LambdaExpression
~static FastExpressionCompiler.LightExpression.Expression.Lambda(System.Type delegateType, FastExpressionCompiler.LightExpression.Expression body, params FastExpressionCompiler.LightExpression.ParameterExpression[] parameters) -> FastExpressionCompiler.LightExpression.LambdaExpression
~static FastExpressionCompiler.LightExpression.Expression.Lambda(System.Type delegateType, FastExpressionCompiler.LightExpression.Expression body, System.Type returnType) -> FastExpressionCompiler.LightExpression.LambdaExpression
~static FastExpressionCompiler.LightExpression.Expression.Lambda<TDelegate>(FastExpressionCompiler.LightExpression.Expression body) -> FastExpressionCompiler.LightExpression.Expression<TDelegate>
~static FastExpressionCompiler.LightExpression.Expression.Lambda<TDelegate>(FastExpressionCompiler.LightExpression.Expression body, FastExpressionCompiler.LightExpression.ParameterExpression[] parameters, System.Type returnType) -> FastExpressionCompiler.LightExpression.Expression<TDelegate>
~static FastExpressionCompiler.LightExpression.Expression.Lambda<TDelegate>(FastExpressionCompiler.LightExpression.Expression body, params FastExpressionCompiler.LightExpression.ParameterExpression[] parameters) -> FastExpressionCompiler.LightExpression.Expression<TDelegate>
~static FastExpressionCompiler.LightExpression.Expression.Lambda<TDelegate>(FastExpressionCompiler.LightExpression.Expression body, string name, params FastExpressionCompiler.LightExpression.ParameterExpression[] parameters) -> FastExpressionCompiler.LightExpression.Expression<TDelegate>
~static FastExpressionCompiler.LightExpression.Expression.Lambda<TDelegate>(FastExpressionCompiler.LightExpression.Expression body, System.Type returnType) -> FastExpressionCompiler.LightExpression.Expression<TDelegate>
~static FastExpressionCompiler.LightExpression.Expression.LeftShift(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.LeftShiftAssign(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.LessThan(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.LessThanOrEqual(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Loop(FastExpressionCompiler.LightExpression.Expression body, System.Linq.Expressions.LabelTarget break = null) -> FastExpressionCompiler.LightExpression.LoopExpression
~static FastExpressionCompiler.LightExpression.Expression.Loop(FastExpressionCompiler.LightExpression.Expression body, System.Linq.Expressions.LabelTarget break, System.Linq.Expressions.LabelTarget continue) -> FastExpressionCompiler.LightExpression.LoopExpression
~static FastExpressionCompiler.LightExpression.Expression.MakeBinary(System.Linq.Expressions.ExpressionType binaryType, FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind kind, System.Linq.Expressions.LabelTarget target, FastExpressionCompiler.LightExpression.Expression value, System.Type type = null) -> FastExpressionCompiler.LightExpression.GotoExpression
~static FastExpressionCompiler.LightExpression.Expression.MakeIndex(FastExpressionCompiler.LightExpression.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable<FastExpressionCompiler.LightExpression.Expression> arguments) -> FastExpressionCompiler.LightExpression.IndexExpression
~static FastExpressionCompiler.LightExpression.Expression.MakeMemberAccess(FastExpressionCompiler.LightExpression.Expression expression, System.Reflection.MemberInfo member) -> FastExpressionCompiler.LightExpression.MemberExpression
~static FastExpressionCompiler.LightExpression.Expression.MakeUnary(System.Linq.Expressions.ExpressionType unaryType, FastExpressionCompiler.LightExpression.Expression operand, System.Type type) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.MemberInit(FastExpressionCompiler.LightExpression.Expression instanceExpr, params FastExpressionCompiler.LightExpression.MemberBinding[] assignments) -> FastExpressionCompiler.LightExpression.MemberInitExpression
~static FastExpressionCompiler.LightExpression.Expression.MemberInit(FastExpressionCompiler.LightExpression.NewExpression newExpr, params FastExpressionCompiler.LightExpression.MemberBinding[] bindings) -> FastExpressionCompiler.LightExpression.MemberInitExpression
~static FastExpressionCompiler.LightExpression.Expression.Modulo(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.ModuloAssign(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Multiply(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.MultiplyAssign(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.MultiplyAssignChecked(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.MultiplyChecked(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Negate(FastExpressionCompiler.LightExpression.Expression expression) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.NegateChecked(FastExpressionCompiler.LightExpression.Expression expression) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.New(System.Reflection.ConstructorInfo ctor) -> FastExpressionCompiler.LightExpression.NewExpression
~static FastExpressionCompiler.LightExpression.Expression.New(System.Reflection.ConstructorInfo ctor, FastExpressionCompiler.LightExpression.Expression arg) -> FastExpressionCompiler.LightExpression.NewExpression
~static FastExpressionCompiler.LightExpression.Expression.New(System.Reflection.ConstructorInfo ctor, FastExpressionCompiler.LightExpression.Expression arg0, FastExpressionCompiler.LightExpression.Expression arg1) -> FastExpressionCompiler.LightExpression.NewExpression
~static FastExpressionCompiler.LightExpression.Expression.New(System.Reflection.ConstructorInfo ctor, FastExpressionCompiler.LightExpression.Expression arg0, FastExpressionCompiler.LightExpression.Expression arg1, FastExpressionCompiler.LightExpression.Expression arg2) -> FastExpressionCompiler.LightExpression.NewExpression
~static FastExpressionCompiler.LightExpression.Expression.New(System.Reflection.ConstructorInfo ctor, FastExpressionCompiler.LightExpression.Expression arg0, FastExpressionCompiler.LightExpression.Expression arg1, FastExpressionCompiler.LightExpression.Expression arg2, FastExpressionCompiler.LightExpression.Expression arg3) -> FastExpressionCompiler.LightExpression.NewExpression
~static FastExpressionCompiler.LightExpression.Expression.New(System.Reflection.ConstructorInfo ctor, FastExpressionCompiler.LightExpression.Expression arg0, FastExpressionCompiler.LightExpression.Expression arg1, FastExpressionCompiler.LightExpression.Expression arg2, FastExpressionCompiler.LightExpression.Expression arg3, FastExpressionCompiler.LightExpression.Expression arg4) -> FastExpressionCompiler.LightExpression.NewExpression
~static FastExpressionCompiler.LightExpression.Expression.New(System.Reflection.ConstructorInfo ctor, params FastExpressionCompiler.LightExpression.Expression[] arguments) -> FastExpressionCompiler.LightExpression.NewExpression
~static FastExpressionCompiler.LightExpression.Expression.New(System.Reflection.ConstructorInfo ctor, System.Collections.Generic.IEnumerable<FastExpressionCompiler.LightExpression.Expression> arguments) -> FastExpressionCompiler.LightExpression.NewExpression
~static FastExpressionCompiler.LightExpression.Expression.New(System.Type type) -> FastExpressionCompiler.LightExpression.NewExpression
~static FastExpressionCompiler.LightExpression.Expression.NewArrayBounds(System.Type type, params FastExpressionCompiler.LightExpression.Expression[] bounds) -> FastExpressionCompiler.LightExpression.NewArrayExpression
~static FastExpressionCompiler.LightExpression.Expression.NewArrayInit(System.Type type, params FastExpressionCompiler.LightExpression.Expression[] initializers) -> FastExpressionCompiler.LightExpression.NewArrayExpression
~static FastExpressionCompiler.LightExpression.Expression.Not(FastExpressionCompiler.LightExpression.Expression expression) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.NotEqual(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.OnesComplement(FastExpressionCompiler.LightExpression.Expression expression) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Or(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.OrAssign(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.OrElse(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Parameter(System.Type type, string name = null) -> FastExpressionCompiler.LightExpression.ParameterExpression
~static FastExpressionCompiler.LightExpression.Expression.PostDecrementAssign(FastExpressionCompiler.LightExpression.Expression expression) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.PostIncrementAssign(FastExpressionCompiler.LightExpression.Expression expression) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Power(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.PowerAssign(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.PreDecrementAssign(FastExpressionCompiler.LightExpression.Expression expression) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.PreIncrementAssign(FastExpressionCompiler.LightExpression.Expression expression) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Property(FastExpressionCompiler.LightExpression.Expression expression, string propertyName) -> FastExpressionCompiler.LightExpression.MemberExpression
~static FastExpressionCompiler.LightExpression.Expression.Property(FastExpressionCompiler.LightExpression.Expression instance, System.Reflection.PropertyInfo indexer, params FastExpressionCompiler.LightExpression.Expression[] arguments) -> FastExpressionCompiler.LightExpression.IndexExpression
~static FastExpressionCompiler.LightExpression.Expression.Property(FastExpressionCompiler.LightExpression.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable<FastExpressionCompiler.LightExpression.Expression> arguments) -> FastExpressionCompiler.LightExpression.IndexExpression
~static FastExpressionCompiler.LightExpression.Expression.Property(FastExpressionCompiler.LightExpression.Expression instance, System.Reflection.PropertyInfo property) -> FastExpressionCompiler.LightExpression.MemberExpression
~static FastExpressionCompiler.LightExpression.Expression.Property(System.Reflection.PropertyInfo property) -> FastExpressionCompiler.LightExpression.MemberExpression
~static FastExpressionCompiler.LightExpression.Expression.PropertyOrField(FastExpressionCompiler.LightExpression.Expression expression, string propertyName) -> FastExpressionCompiler.LightExpression.MemberExpression
~static FastExpressionCompiler.LightExpression.Expression.Quote(FastExpressionCompiler.LightExpression.Expression expression) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.ReferenceEqual(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.ReferenceNotEqual(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Return(System.Linq.Expressions.LabelTarget target, FastExpressionCompiler.LightExpression.Expression value = null, System.Type type = null) -> FastExpressionCompiler.LightExpression.GotoExpression
~static FastExpressionCompiler.LightExpression.Expression.RightShift(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.RightShiftAssign(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Subtract(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.SubtractAssign(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.SubtractAssignChecked(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.SubtractChecked(FastExpressionCompiler.LightExpression.Expression left, FastExpressionCompiler.LightExpression.Expression right) -> FastExpressionCompiler.LightExpression.BinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Switch(FastExpressionCompiler.LightExpression.Expression switchValue, FastExpressionCompiler.LightExpression.Expression defaultBody, params FastExpressionCompiler.LightExpression.SwitchCase[] cases) -> FastExpressionCompiler.LightExpression.SwitchExpression
~static FastExpressionCompiler.LightExpression.Expression.Switch(FastExpressionCompiler.LightExpression.Expression switchValue, FastExpressionCompiler.LightExpression.Expression defaultBody, System.Reflection.MethodInfo comparison, params FastExpressionCompiler.LightExpression.SwitchCase[] cases) -> FastExpressionCompiler.LightExpression.SwitchExpression
~static FastExpressionCompiler.LightExpression.Expression.Switch(FastExpressionCompiler.LightExpression.Expression switchValue, params FastExpressionCompiler.LightExpression.SwitchCase[] cases) -> FastExpressionCompiler.LightExpression.SwitchExpression
~static FastExpressionCompiler.LightExpression.Expression.Switch(System.Type type, FastExpressionCompiler.LightExpression.Expression switchValue, FastExpressionCompiler.LightExpression.Expression defaultBody, System.Reflection.MethodInfo comparison, params FastExpressionCompiler.LightExpression.SwitchCase[] cases) -> FastExpressionCompiler.LightExpression.SwitchExpression
~static FastExpressionCompiler.LightExpression.Expression.Switch(System.Type type, FastExpressionCompiler.LightExpression.Expression switchValue, FastExpressionCompiler.LightExpression.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable<FastExpressionCompiler.LightExpression.SwitchCase> cases) -> FastExpressionCompiler.LightExpression.SwitchExpression
~static FastExpressionCompiler.LightExpression.Expression.SwitchCase(FastExpressionCompiler.LightExpression.Expression body, params FastExpressionCompiler.LightExpression.Expression[] testValues) -> FastExpressionCompiler.LightExpression.SwitchCase
~static FastExpressionCompiler.LightExpression.Expression.SwitchCase(FastExpressionCompiler.LightExpression.Expression body, System.Collections.Generic.IEnumerable<FastExpressionCompiler.LightExpression.Expression> testValues) -> FastExpressionCompiler.LightExpression.SwitchCase
~static FastExpressionCompiler.LightExpression.Expression.Throw(FastExpressionCompiler.LightExpression.Expression value) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Throw(FastExpressionCompiler.LightExpression.Expression value, System.Type type) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.TryCatch(FastExpressionCompiler.LightExpression.Expression body, params FastExpressionCompiler.LightExpression.CatchBlock[] handlers) -> FastExpressionCompiler.LightExpression.TryExpression
~static FastExpressionCompiler.LightExpression.Expression.TryCatchFinally(FastExpressionCompiler.LightExpression.Expression body, FastExpressionCompiler.LightExpression.Expression finally, params FastExpressionCompiler.LightExpression.CatchBlock[] handlers) -> FastExpressionCompiler.LightExpression.TryExpression
~static FastExpressionCompiler.LightExpression.Expression.TryFinally(FastExpressionCompiler.LightExpression.Expression body, FastExpressionCompiler.LightExpression.Expression finally) -> FastExpressionCompiler.LightExpression.TryExpression
~static FastExpressionCompiler.LightExpression.Expression.TypeAs(FastExpressionCompiler.LightExpression.Expression expression, System.Type type) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.TypeEqual(FastExpressionCompiler.LightExpression.Expression operand, System.Type type) -> FastExpressionCompiler.LightExpression.TypeBinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.TypeIs(FastExpressionCompiler.LightExpression.Expression operand, System.Type type) -> FastExpressionCompiler.LightExpression.TypeBinaryExpression
~static FastExpressionCompiler.LightExpression.Expression.UnaryPlus(FastExpressionCompiler.LightExpression.Expression expression) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Unbox(FastExpressionCompiler.LightExpression.Expression expression, System.Type type) -> FastExpressionCompiler.LightExpression.UnaryExpression
~static FastExpressionCompiler.LightExpression.Expression.Variable(System.Type type, string name = null) -> FastExpressionCompiler.LightExpression.ParameterExpression
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.ArrayClosureArrayField -> System.Reflection.FieldInfo
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.ArrayClosureWithNonPassedParamsConstructor -> System.Reflection.ConstructorInfo
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.ArrayClosureWithNonPassedParamsField -> System.Reflection.FieldInfo
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast(this FastExpressionCompiler.LightExpression.Expression<System.Action> lambdaExpr, bool ifFastFailedReturnNull = false) -> System.Action
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast(this FastExpressionCompiler.LightExpression.LambdaExpression lambdaExpr, bool ifFastFailedReturnNull = false) -> System.Delegate
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast<R>(this FastExpressionCompiler.LightExpression.Expression<System.Func<R>> lambdaExpr, bool ifFastFailedReturnNull = false) -> System.Func<R>
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast<T1, R>(this FastExpressionCompiler.LightExpression.Expression<System.Func<T1, R>> lambdaExpr, bool ifFastFailedReturnNull = false) -> System.Func<T1, R>
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast<T1, T2, R>(this FastExpressionCompiler.LightExpression.Expression<System.Func<T1, T2, R>> lambdaExpr, bool ifFastFailedReturnNull = false) -> System.Func<T1, T2, R>
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast<T1, T2, T3, R>(this FastExpressionCompiler.LightExpression.Expression<System.Func<T1, T2, T3, R>> lambdaExpr, bool ifFastFailedReturnNull = false) -> System.Func<T1, T2, T3, R>
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast<T1, T2, T3, T4, R>(this FastExpressionCompiler.LightExpression.Expression<System.Func<T1, T2, T3, T4, R>> lambdaExpr, bool ifFastFailedReturnNull = false) -> System.Func<T1, T2, T3, T4, R>
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast<T1, T2, T3, T4, T5, R>(this FastExpressionCompiler.LightExpression.Expression<System.Func<T1, T2, T3, T4, T5, R>> lambdaExpr, bool ifFastFailedReturnNull = false) -> System.Func<T1, T2, T3, T4, T5, R>
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast<T1, T2, T3, T4, T5, T6, R>(this FastExpressionCompiler.LightExpression.Expression<System.Func<T1, T2, T3, T4, T5, T6, R>> lambdaExpr, bool ifFastFailedReturnNull = false) -> System.Func<T1, T2, T3, T4, T5, T6, R>
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast<T1, T2, T3, T4, T5, T6>(this FastExpressionCompiler.LightExpression.Expression<System.Action<T1, T2, T3, T4, T5, T6>> lambdaExpr, bool ifFastFailedReturnNull = false) -> System.Action<T1, T2, T3, T4, T5, T6>
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast<T1, T2, T3, T4, T5>(this FastExpressionCompiler.LightExpression.Expression<System.Action<T1, T2, T3, T4, T5>> lambdaExpr, bool ifFastFailedReturnNull = false) -> System.Action<T1, T2, T3, T4, T5>
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast<T1, T2, T3, T4>(this FastExpressionCompiler.LightExpression.Expression<System.Action<T1, T2, T3, T4>> lambdaExpr, bool ifFastFailedReturnNull = false) -> System.Action<T1, T2, T3, T4>
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast<T1, T2, T3>(this FastExpressionCompiler.LightExpression.Expression<System.Action<T1, T2, T3>> lambdaExpr, bool ifFastFailedReturnNull = false) -> System.Action<T1, T2, T3>
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast<T1, T2>(this FastExpressionCompiler.LightExpression.Expression<System.Action<T1, T2>> lambdaExpr, bool ifFastFailedReturnNull = false) -> System.Action<T1, T2>
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast<T1>(this FastExpressionCompiler.LightExpression.Expression<System.Action<T1>> lambdaExpr, bool ifFastFailedReturnNull = false) -> System.Action<T1>
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast<TDelegate>(this FastExpressionCompiler.LightExpression.Expression<TDelegate> lambdaExpr, bool ifFastFailedReturnNull = false) -> TDelegate
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast<TDelegate>(this FastExpressionCompiler.LightExpression.LambdaExpression lambdaExpr, bool ifFastFailedReturnNull = false) -> TDelegate
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFastToIL(this FastExpressionCompiler.LightExpression.LambdaExpression lambdaExpr, System.Reflection.Emit.ILGenerator il, bool ifFastFailedReturnNull = false) -> bool
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileSys(this FastExpressionCompiler.LightExpression.LambdaExpression lambdaExpr) -> System.Delegate
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileSys<TDelegate>(this FastExpressionCompiler.LightExpression.Expression<TDelegate> lambdaExpr) -> TDelegate
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.IsClosureBoundConstant(object value, System.Reflection.TypeInfo type) -> bool
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.NestedLambdaWithConstantsAndNestedLambdas.ConstantsAndNestedLambdasField -> System.Reflection.FieldInfo
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.NestedLambdaWithConstantsAndNestedLambdas.NestedLambdaField -> System.Reflection.FieldInfo
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.TryCompile(System.Type delegateType, FastExpressionCompiler.LightExpression.Expression bodyExpr, System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.ParameterExpression> paramExprs, System.Type[] paramTypes, System.Type returnType) -> object
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.TryCompile<TDelegate>(FastExpressionCompiler.LightExpression.Expression bodyExpr, System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.ParameterExpression> paramExprs, System.Type[] paramTypes, System.Type returnType) -> TDelegate
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.TryCompile<TDelegate>(this FastExpressionCompiler.LightExpression.LambdaExpression lambdaExpr) -> TDelegate
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.TryCompileWithoutClosure<TDelegate>(this FastExpressionCompiler.LightExpression.LambdaExpression lambdaExpr) -> TDelegate
~static FastExpressionCompiler.LightExpression.ExpressionCompiler.TryCompileWithPreCreatedClosure<TDelegate>(this FastExpressionCompiler.LightExpression.LambdaExpression lambdaExpr, params FastExpressionCompiler.LightExpression.ConstantExpression[] closureConstantsExprs) -> TDelegate
~static FastExpressionCompiler.LightExpression.ILGeneratorHacks.GetNextLocalVarIndex(this System.Reflection.Emit.ILGenerator il, System.Type t) -> int
~static FastExpressionCompiler.LightExpression.OneVariableTwoExpressionBlockExpression.explicit operator FastExpressionCompiler.LightExpression.BlockExpression(FastExpressionCompiler.LightExpression.OneVariableTwoExpressionBlockExpression x) -> FastExpressionCompiler.LightExpression.BlockExpression
~static ImTools.ArrayTools.Append<T>(this System.Collections.Generic.IEnumerable<T> source, System.Collections.Generic.IEnumerable<T> other) -> T[]
~static ImTools.ArrayTools.Append<T>(this T[] source, params T[] added) -> T[]
~static ImTools.ArrayTools.AppendOrUpdate<T>(this T[] source, T value, int index = -1) -> T[]
~static ImTools.ArrayTools.AppendTo<T>(T[] source, int sourcePos, int count, T[] results = null) -> T[]
~static ImTools.ArrayTools.Copy<T>(this T[] items) -> T[]
~static ImTools.ArrayTools.Empty<T>() -> T[]
~static ImTools.ArrayTools.EmptyIfNull<T>(this T[] source) -> T[]
~static ImTools.ArrayTools.FindFirst<T, S>(this T[] source, S state, System.Func<S, T, bool> predicate) -> T
~static ImTools.ArrayTools.FindFirst<T>(this System.Collections.Generic.IEnumerable<T> source, System.Func<T, bool> predicate) -> T
~static ImTools.ArrayTools.FindFirst<T>(this T[] source, System.Func<T, bool> predicate) -> T
~static ImTools.ArrayTools.ForEach<T>(this T[] source, System.Action<T> action) -> void
~static ImTools.ArrayTools.IndexOf<T, S>(this T[] source, S state, System.Func<S, T, bool> predicate) -> int
~static ImTools.ArrayTools.IndexOf<T>(this T[] source, System.Func<T, bool> predicate) -> int
~static ImTools.ArrayTools.IndexOf<T>(this T[] source, T value) -> int
~static ImTools.ArrayTools.IndexOfReference<T>(this T[] source, T reference) -> int
~static ImTools.ArrayTools.IsNullOrEmpty<T>(this T[] source) -> bool
~static ImTools.ArrayTools.Map<T, R>(this System.Collections.Generic.IEnumerable<T> source, System.Func<T, R> map) -> System.Collections.Generic.IEnumerable<R>
~static ImTools.ArrayTools.Map<T, R>(this T[] source, System.Func<T, R> map) -> R[]
~static ImTools.ArrayTools.Map<T, S, R>(this T[] source, S state, System.Func<S, T, R> map) -> R[]
~static ImTools.ArrayTools.Match<T, R>(this System.Collections.Generic.IEnumerable<T> source, System.Func<T, bool> condition, System.Func<T, R> map) -> System.Collections.Generic.IEnumerable<R>
~static ImTools.ArrayTools.Match<T, R>(this T[] source, System.Func<T, bool> condition, System.Func<T, R> map) -> R[]
~static ImTools.ArrayTools.Match<T, S, R>(this T[] source, S state, System.Func<S, T, bool> condition, System.Func<S, T, R> map) -> R[]
~static ImTools.ArrayTools.Match<T, S>(this T[] source, S state, System.Func<S, T, bool> condition) -> T[]
~static ImTools.ArrayTools.Match<T>(this System.Collections.Generic.IEnumerable<T> source, System.Func<T, bool> condition) -> System.Collections.Generic.IEnumerable<T>
~static ImTools.ArrayTools.Match<T>(this T[] source, System.Func<T, bool> condition) -> T[]
~static ImTools.ArrayTools.One<T>(this T one) -> T[]
~static ImTools.ArrayTools.Remove<T>(this T[] source, T value) -> T[]
~static ImTools.ArrayTools.RemoveAt<T>(this T[] source, int index) -> T[]
~static ImTools.ArrayTools.SingleOrDefaultIfMany<T>(this System.Collections.Generic.IEnumerable<T> source) -> T
~static ImTools.ArrayTools.ToArrayOrSelf<T>(this System.Collections.Generic.IEnumerable<T> source) -> T[]
~static ImTools.ArrayTools.ToListOrSelf<T>(this System.Collections.Generic.IEnumerable<T> source) -> System.Collections.Generic.IList<T>
~static ImTools.ArrayTools.UpdateItemOrShrinkUnsafe<T, S>(this T[] source, S state, System.Func<S, T, T> tryMap) -> T[]
~static ImTools.Box<TBox, T>.Of(T x) -> TBox
~static ImTools.Fun.Do<T, S>(this T x, S state, System.Action<T, S> effect) -> T
~static ImTools.Fun.Do<T>(this T x, System.Action<T> effect) -> T
~static ImTools.Fun.To<R>(this object x) -> R
~static ImTools.Fun.To<T, R>(this T x, System.Func<T, R> map) -> R
~static ImTools.Fun.To<T, S, R>(this T x, S state, System.Func<T, S, R> map) -> R
~static ImTools.ImHashMap.AddOrUpdate<V>(this ImTools.ImHashMap<System.Type, V> map, System.Type key, V value) -> ImTools.ImHashMap<System.Type, V>
~static ImTools.ImHashMap.Contains<K, V>(this ImTools.ImHashMap<K, V> map, int hash, K key) -> bool
~static ImTools.ImHashMap.Contains<K, V>(this ImTools.ImHashMap<K, V> map, K key) -> bool
~static ImTools.ImHashMap.GetEntryOrDefault<K, V>(this ImTools.ImHashMap<K, V> map, int hash, K key) -> ImTools.ImHashMapEntry<K, V>
~static ImTools.ImHashMap.GetEntryOrDefault<K, V>(this ImTools.ImHashMap<K, V> map, K key) -> ImTools.ImHashMapEntry<K, V>
~static ImTools.ImHashMap.GetValueOrDefault<K, V>(this ImTools.ImHashMap<K, V> map, int hash, K key, V defaultValue = default(V)) -> V
~static ImTools.ImHashMap.GetValueOrDefault<K, V>(this ImTools.ImHashMap<K, V> map, K key, V defaultValue = default(V)) -> V
~static ImTools.ImHashMap.GetValueOrDefault<V>(this ImTools.ImHashMap<System.Type, V> map, int hash, System.Type key, V defaultValue = default(V)) -> V
~static ImTools.ImHashMap.GetValueOrDefault<V>(this ImTools.ImHashMap<System.Type, V> map, System.Type key, V defaultValue = default(V)) -> V
~static ImTools.ImHashMap.TryFind<K, V>(this ImTools.ImHashMap<K, V> map, int hash, K key, out V value) -> bool
~static ImTools.ImHashMap.TryFind<K, V>(this ImTools.ImHashMap<K, V> map, K key, out V value) -> bool
~static ImTools.ImHashMap.TryFind<V>(this ImTools.ImHashMap<System.Type, V> map, int hash, System.Type key, out V value) -> bool
~static ImTools.ImHashMap.TryFind<V>(this ImTools.ImHashMap<System.Type, V> map, System.Type key, out V value) -> bool
~static ImTools.ImHashMapSlots.AddOrKeep<K, V>(this ImTools.ImHashMap<K, V>[] slots, int hash, K key, V value, int hashMaskToFindSlot = 31) -> void
~static ImTools.ImHashMapSlots.AddOrKeep<K, V>(this ImTools.ImHashMap<K, V>[] slots, K key, V value, int hashMaskToFindSlot = 31) -> void
~static ImTools.ImHashMapSlots.AddOrUpdate<K, V>(this ImTools.ImHashMap<K, V>[] slots, int hash, K key, V value, ImTools.Update<K, V> update, int hashMaskToFindSlot = 31) -> void
~static ImTools.ImHashMapSlots.AddOrUpdate<K, V>(this ImTools.ImHashMap<K, V>[] slots, int hash, K key, V value, int hashMaskToFindSlot = 31) -> void
~static ImTools.ImHashMapSlots.AddOrUpdate<K, V>(this ImTools.ImHashMap<K, V>[] slots, K key, V value, ImTools.Update<K, V> updateValue, int hashMaskToFindSlot = 31) -> void
~static ImTools.ImHashMapSlots.AddOrUpdate<K, V>(this ImTools.ImHashMap<K, V>[] slots, K key, V value, int hashMaskToFindSlot = 31) -> void
~static ImTools.ImHashMapSlots.CreateWithEmpty<K, V>(int slotCountPowerOfTwo = 32) -> ImTools.ImHashMap<K, V>[]
~static ImTools.ImHashMapSlots.Fold<K, V, S>(this ImTools.ImHashMap<K, V>[] slots, S state, System.Func<ImTools.ImHashMapEntry<K, V>, S, S> reduce) -> S
~static ImTools.ImHashMapSlots.RefAddOrKeepSlot<K, V>(ref ImTools.ImHashMap<K, V> slot, int hash, K key, V value) -> void
~static ImTools.ImHashMapSlots.RefAddOrUpdateSlot<K, V>(ref ImTools.ImHashMap<K, V> slot, int hash, K key, V value) -> void
~static ImTools.ImHashMapSlots.RefAddOrUpdateSlot<K, V>(ref ImTools.ImHashMap<K, V> slot, int hash, K key, V value, ImTools.Update<K, V> update) -> void
~static ImTools.ImHashMapSlots.RefUpdateSlot<K, V>(ref ImTools.ImHashMap<K, V> slot, int hash, K key, V value) -> void
~static ImTools.ImHashMapSlots.Update<K, V>(this ImTools.ImHashMap<K, V>[] slots, int hash, K key, V value, int hashMaskToFindSlot = 31) -> void
~static ImTools.ImHashMapSlots.Update<K, V>(this ImTools.ImHashMap<K, V>[] slots, K key, V value, int hashMaskToFindSlot = 31) -> void
~static ImTools.ImList.Deconstruct<T>(this ImTools.ImList<T> list, out T head, out ImTools.ImList<T> tail, out bool isEmpty) -> void
~static ImTools.ImList.Fold<T, S>(this ImTools.ImList<T> list, S state, System.Func<T, int, S, S> reduce) -> S
~static ImTools.ImList.Fold<T, S>(this ImTools.ImList<T> list, S state, System.Func<T, S, S> reduce) -> S
~static ImTools.ImList.ForEach<T>(this ImTools.ImList<T> list, System.Action<T> effect) -> void
~static ImTools.ImList.List<T>(params T[] items) -> ImTools.ImList<T>
~static ImTools.ImList.List<T>(this T head) -> ImTools.ImList<T>
~static ImTools.ImList.List<T>(this T head, ImTools.ImList<T> tail) -> ImTools.ImList<T>
~static ImTools.ImList.Map<T, R>(this ImTools.ImList<T> list, System.Func<T, int, R> map) -> ImTools.ImList<R>
~static ImTools.ImList.Map<T, R>(this ImTools.ImList<T> list, System.Func<T, R> map) -> ImTools.ImList<R>
~static ImTools.ImList.Reverse<T>(this ImTools.ImList<T> list) -> ImTools.ImList<T>
~static ImTools.ImList.ToArray<T>(this ImTools.ImList<T> source) -> T[]
~static ImTools.ImList.ToImList<T>(this System.Collections.Generic.IEnumerable<T> source) -> ImTools.ImList<T>
~static ImTools.ImList.ToImList<T>(this System.Collections.Generic.IList<T> source) -> ImTools.ImList<T>
~static ImTools.ImMap.AddEntryUnsafe<V>(this ImTools.ImMap<V> map, ImTools.ImMapEntry<V> entry) -> ImTools.ImMap<V>
~static ImTools.ImMap.AddOrKeep<K>(this ImTools.ImMap<ImTools.ImMap.KValue<K>> map, int hash, K key) -> ImTools.ImMap<ImTools.ImMap.KValue<K>>
~static ImTools.ImMap.AddOrKeep<K>(this ImTools.ImMap<ImTools.ImMap.KValue<K>> map, int hash, K key, object value) -> ImTools.ImMap<ImTools.ImMap.KValue<K>>
~static ImTools.ImMap.AddOrKeep<V>(this ImTools.ImMap<V> map, int key) -> ImTools.ImMap<V>
~static ImTools.ImMap.AddOrKeep<V>(this ImTools.ImMap<V> map, int key, V value) -> ImTools.ImMap<V>
~static ImTools.ImMap.AddOrKeepEntry<V>(this ImTools.ImMap<V> map, ImTools.ImMapEntry<V> entry) -> ImTools.ImMap<V>
~static ImTools.ImMap.AddOrUpdate(this ImTools.ImMap<ImTools.ImMap.KValue<System.Type>> map, System.Type type, object value) -> ImTools.ImMap<ImTools.ImMap.KValue<System.Type>>
~static ImTools.ImMap.AddOrUpdate<K>(this ImTools.ImMap<ImTools.ImMap.KValue<K>> map, int hash, ImTools.ImMapEntry<ImTools.ImMap.KValue<K>> entry) -> ImTools.ImMap<ImTools.ImMap.KValue<K>>
~static ImTools.ImMap.AddOrUpdate<K>(this ImTools.ImMap<ImTools.ImMap.KValue<K>> map, int hash, K key, object value) -> ImTools.ImMap<ImTools.ImMap.KValue<K>>
~static ImTools.ImMap.AddOrUpdate<K>(this ImTools.ImMap<ImTools.ImMap.KValue<K>> map, int hash, K key, object value, ImTools.Update<K, object> update) -> ImTools.ImMap<ImTools.ImMap.KValue<K>>
~static ImTools.ImMap.AddOrUpdate<V>(this ImTools.ImMap<V> map, int key, V value) -> ImTools.ImMap<V>
~static ImTools.ImMap.AddOrUpdateEntry<V>(this ImTools.ImMap<V> map, ImTools.ImMapEntry<V> entry) -> ImTools.ImMap<V>
~static ImTools.ImMap.Contains<V>(this ImTools.ImMap<V> map, int key) -> bool
~static ImTools.ImMap.CreateKValueEntry<K>(int hash, K key) -> ImTools.ImMapEntry<ImTools.ImMap.KValue<K>>
~static ImTools.ImMap.Enumerate<K>(this ImTools.ImMap<ImTools.ImMap.KValue<K>> map) -> System.Collections.Generic.IEnumerable<ImTools.ImMapEntry<ImTools.ImMap.KValue<K>>>
~static ImTools.ImMap.Enumerate<V>(this ImTools.ImMap<V> map, ImTools.ImMapTree<V>[] parentStack = null) -> System.Collections.Generic.IEnumerable<ImTools.ImMapEntry<V>>
~static ImTools.ImMap.Fold<K, S>(this ImTools.ImMap<ImTools.ImMap.KValue<K>> map, S state, System.Func<ImTools.ImMapEntry<ImTools.ImMap.KValue<K>>, S, S> reduce, ImTools.ImMapTree<ImTools.ImMap.KValue<K>>[] parentsStack = null) -> S
~static ImTools.ImMap.Fold<V, S, A>(this ImTools.ImMap<V> map, S state, A a, System.Func<ImTools.ImMapEntry<V>, S, A, S> reduce, ImTools.ImMapTree<V>[] parentStack = null) -> S
~static ImTools.ImMap.Fold<V, S>(this ImTools.ImMap<V> map, S state, System.Func<ImTools.ImMapEntry<V>, S, S> reduce, ImTools.ImMapTree<V>[] parentStack = null) -> S
~static ImTools.ImMap.GetEntryOrDefault(this ImTools.ImMap<ImTools.ImMap.KValue<System.Type>> map, int hash, System.Type type) -> ImTools.ImMapEntry<ImTools.ImMap.KValue<System.Type>>
~static ImTools.ImMap.GetEntryOrDefault<K>(this ImTools.ImMap<ImTools.ImMap.KValue<K>> map, int hash, K key) -> ImTools.ImMapEntry<ImTools.ImMap.KValue<K>>
~static ImTools.ImMap.GetEntryOrDefault<V>(this ImTools.ImMap<V> map, int key) -> ImTools.ImMapEntry<V>
~static ImTools.ImMap.GetValueOrDefault(this ImTools.ImMap<ImTools.ImMap.KValue<System.Type>> map, int hash, System.Type typeKey) -> object
~static ImTools.ImMap.GetValueOrDefault(this ImTools.ImMap<ImTools.ImMap.KValue<System.Type>> map, System.Type typeKey) -> object
~static ImTools.ImMap.GetValueOrDefault<K>(this ImTools.ImMap<ImTools.ImMap.KValue<K>> map, int hash, K key) -> object
~static ImTools.ImMap.GetValueOrDefault<V>(this ImTools.ImMap<V> map, int key) -> V
~static ImTools.ImMap.TryFind<K>(this ImTools.ImMap<ImTools.ImMap.KValue<K>> map, int hash, K key, out object value) -> bool
~static ImTools.ImMap.TryFind<V>(this ImTools.ImMap<V> map, int key, out V value) -> bool
~static ImTools.ImMap.TryFindEntry<V>(this ImTools.ImMap<V> map, int key, out ImTools.ImMapEntry<V> result) -> bool
~static ImTools.ImMap.Update<K>(this ImTools.ImMap<ImTools.ImMap.KValue<K>> map, int hash, K key, object value, ImTools.Update<K, object> update = null) -> ImTools.ImMap<ImTools.ImMap.KValue<K>>
~static ImTools.ImMap.Update<V>(this ImTools.ImMap<V> map, int key, V value) -> ImTools.ImMap<V>
~static ImTools.ImMap.UpdateEntryUnsafe<V>(this ImTools.ImMap<V> map, ImTools.ImMapEntry<V> entry) -> ImTools.ImMap<V>
~static ImTools.ImMap.UpdateToDefault<K>(this ImTools.ImMap<ImTools.ImMap.KValue<K>> map, int hash, K key) -> ImTools.ImMap<ImTools.ImMap.KValue<K>>
~static ImTools.ImMap.UpdateToDefault<V>(this ImTools.ImMap<V> map, int key) -> ImTools.ImMap<V>
~static ImTools.ImMap.Visit<K, S>(this ImTools.ImMap<ImTools.ImMap.KValue<K>> map, S state, System.Action<ImTools.ImMapEntry<ImTools.ImMap.KValue<K>>, S> effect, ImTools.ImMapTree<ImTools.ImMap.KValue<K>>[] parentsStack = null) -> S
~static ImTools.ImMap.Visit<K>(this ImTools.ImMap<ImTools.ImMap.KValue<K>> map, System.Action<ImTools.ImMapEntry<ImTools.ImMap.KValue<K>>> effect, ImTools.ImMapTree<ImTools.ImMap.KValue<K>>[] parentsStack = null) -> void
~static ImTools.ImMap.Visit<V>(this ImTools.ImMap<V> map, System.Action<ImTools.ImMapEntry<V>> visit, ImTools.ImMapTree<V>[] parentStack = null) -> void
~static ImTools.ImMapSlots.AddOrKeep<V>(this ImTools.ImMap<V>[] slots, int key, int keyMaskToFindSlot = 31) -> void
~static ImTools.ImMapSlots.AddOrKeep<V>(this ImTools.ImMap<V>[] slots, int key, V value, int keyMaskToFindSlot = 31) -> void
~static ImTools.ImMapSlots.AddOrUpdate<V>(this ImTools.ImMap<V>[] slots, int key, V value, int keyMaskToFindSlot = 31) -> void
~static ImTools.ImMapSlots.CreateWithEmpty<V>(int slotCountPowerOfTwo = 32) -> ImTools.ImMap<V>[]
~static ImTools.ImMapSlots.Fold<V, S>(this ImTools.ImMap<V>[] slots, S state, System.Func<ImTools.ImMapEntry<V>, S, S> reduce) -> S
~static ImTools.ImMapSlots.RefAddOrKeepSlot<V>(ref ImTools.ImMap<V> slot, int key) -> void
~static ImTools.ImMapSlots.RefAddOrKeepSlot<V>(ref ImTools.ImMap<V> slot, int key, V value) -> void
~static ImTools.ImMapSlots.RefAddOrUpdateSlot<V>(ref ImTools.ImMap<V> slot, int key, V value) -> void
~static ImTools.ImZipper.Fold<T, S>(this ImTools.ImZipper<T> z, S state, System.Func<T, int, S, S> reduce) -> S
~static ImTools.ImZipper.Fold<T, S>(this ImTools.ImZipper<T> z, S state, System.Func<T, S, S> reduce) -> S
~static ImTools.ImZipper.ForEach<T>(this ImTools.ImZipper<T> z, System.Action<T> effect) -> void
~static ImTools.ImZipper.RemoveAt<T>(this ImTools.ImZipper<T> z, int i) -> ImTools.ImZipper<T>
~static ImTools.ImZipper.ShiftTo<T>(this ImTools.ImZipper<T> z, int i) -> ImTools.ImZipper<T>
~static ImTools.ImZipper.ToArray<T>(this ImTools.ImZipper<T> z) -> T[]
~static ImTools.ImZipper.Update<T>(this ImTools.ImZipper<T> z, System.Func<T, T> update) -> ImTools.ImZipper<T>
~static ImTools.ImZipper.UpdateAt<T>(this ImTools.ImZipper<T> z, int i, System.Func<T, T> update) -> ImTools.ImZipper<T>
~static ImTools.ImZipper.Zip<T>(params T[] items) -> ImTools.ImZipper<T>
~static ImTools.Item<TItem, T>.Of(T x) -> ImTools.Item<TItem, T>.item
~static ImTools.KV.Of<K, V>(K key, V value) -> ImTools.KV<K, V>
~static ImTools.KV.WithValue<K, V>(this ImTools.KV<K, V> kv, V value) -> ImTools.KV<K, V>
~static ImTools.Lazy.Of<T>(System.Func<T> valueFactory) -> System.Lazy<T>
~static ImTools.Ref.NewRef<T>(this ImTools.Ref<T> original) -> ImTools.Ref<T>
~static ImTools.Ref.Of<T>(T value) -> ImTools.Ref<T>
~static ImTools.Ref.Swap<T, A, B, C>(ref T value, A a, B b, C c, System.Func<T, A, B, C, T> getNewValue, int retryCountUntilThrow = 50) -> T
~static ImTools.Ref.Swap<T, A, B>(ref T value, A a, B b, System.Func<T, A, B, T> getNewValue, int retryCountUntilThrow = 50) -> T
~static ImTools.Ref.Swap<T, A>(ref T value, A a, System.Func<T, A, T> getNewValue, int retryCountUntilThrow = 50) -> T
~static ImTools.Ref.Swap<T>(ref T value, System.Func<T, T> getNewValue, int retryCountUntilThrow = 50) -> T
~static ImTools.Ref.SwapAndGetNewValue<T, A>(ref T value, A a, System.Func<T, A, T> getNewValue, int retryCountUntilThrow = 50) -> T
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Of(T1 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Of(T10 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Of(T2 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Of(T3 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Of(T4 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Of(T5 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Of(T6 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Of(T7 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Of(T8 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Of(T9 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Of(T1 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Of(T2 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Of(T3 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Of(T4 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Of(T5 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Of(T6 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Of(T7 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Of(T8 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Of(T9 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Of(T1 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Of(T2 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Of(T3 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Of(T4 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Of(T5 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Of(T6 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Of(T7 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.Of(T8 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Of(T1 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Of(T2 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Of(T3 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Of(T4 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Of(T5 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Of(T6 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.Of(T7 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6, T7>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Of(T1 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Of(T2 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Of(T3 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Of(T4 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Of(T5 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.Of(T6 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5, T6>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Of(T1 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Of(T2 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Of(T3 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Of(T4 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4, T5>.Of(T5 x) -> ImTools.Union<TUnion, T1, T2, T3, T4, T5>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4>.Of(T1 x) -> ImTools.Union<TUnion, T1, T2, T3, T4>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4>.Of(T2 x) -> ImTools.Union<TUnion, T1, T2, T3, T4>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4>.Of(T3 x) -> ImTools.Union<TUnion, T1, T2, T3, T4>.union
~static ImTools.Union<TUnion, T1, T2, T3, T4>.Of(T4 x) -> ImTools.Union<TUnion, T1, T2, T3, T4>.union
~static ImTools.Union<TUnion, T1, T2, T3>.Of(T1 x) -> ImTools.Union<TUnion, T1, T2, T3>.union
~static ImTools.Union<TUnion, T1, T2, T3>.Of(T2 x) -> ImTools.Union<TUnion, T1, T2, T3>.union
~static ImTools.Union<TUnion, T1, T2, T3>.Of(T3 x) -> ImTools.Union<TUnion, T1, T2, T3>.union
~static ImTools.Union<TUnion, T1, T2>.Of(T1 x) -> ImTools.Union<TUnion, T1, T2>.union
~static ImTools.Union<TUnion, T1, T2>.Of(T2 x) -> ImTools.Union<TUnion, T1, T2>.union
~static readonly DryIoc.AsyncExecutionFlowScopeContext.Default -> DryIoc.AsyncExecutionFlowScopeContext
~static readonly DryIoc.AsyncExecutionFlowScopeContext.ScopeContextName -> string
~static readonly DryIoc.DefaultDynamicKey.Value -> DryIoc.DefaultDynamicKey
~static readonly DryIoc.DefaultKey.Value -> DryIoc.DefaultKey
~static readonly DryIoc.Error.Messages -> string[]
~static readonly DryIoc.FactoryDelegateCompiler.FactoryDelegateParamExprs -> FastExpressionCompiler.LightExpression.ParameterExpression[]
~static readonly DryIoc.FactoryDelegateCompiler.FactoryDelegateParamTypes -> System.Type[]
~static readonly DryIoc.FactoryDelegateCompiler.ResolverContextParamExpr -> FastExpressionCompiler.LightExpression.ParameterExpression
~static readonly DryIoc.FactoryMethod.ConstructorWithResolvableArguments -> DryIoc.FactoryMethodSelector
~static readonly DryIoc.FactoryMethod.ConstructorWithResolvableArgumentsIncludingNonPublic -> DryIoc.FactoryMethodSelector
~static readonly DryIoc.Made.Default -> DryIoc.Made
~static readonly DryIoc.Messages.EmptyResponse.Task -> System.Threading.Tasks.Task<DryIoc.Messages.EmptyResponse>
~static readonly DryIoc.Registrator.ExcludedGeneralPurposeServiceTypes -> string[]
~static readonly DryIoc.Request.Empty -> DryIoc.Request
~static readonly DryIoc.Request.EmptyOpensResolutionScope -> DryIoc.Request
~static readonly DryIoc.ResolverContext.CurrentScopeExpr -> FastExpressionCompiler.LightExpression.Expression
~static readonly DryIoc.ResolverContext.ParentExpr -> FastExpressionCompiler.LightExpression.Expression
~static readonly DryIoc.ResolverContext.RootOrSelfExpr -> FastExpressionCompiler.LightExpression.Expression
~static readonly DryIoc.ResolverContext.SingletonScopeExpr -> FastExpressionCompiler.LightExpression.Expression
~static readonly DryIoc.Reuse.InCurrentScope -> DryIoc.IReuse
~static readonly DryIoc.Reuse.InResolutionScope -> DryIoc.IReuse
~static readonly DryIoc.Reuse.InThread -> DryIoc.IReuse
~static readonly DryIoc.Reuse.InWebRequest -> DryIoc.IReuse
~static readonly DryIoc.Reuse.Scoped -> DryIoc.IReuse
~static readonly DryIoc.Reuse.ScopedOrSingleton -> DryIoc.IReuse
~static readonly DryIoc.Reuse.Singleton -> DryIoc.IReuse
~static readonly DryIoc.Reuse.Transient -> DryIoc.IReuse
~static readonly DryIoc.Rules.Default -> DryIoc.Rules
~static readonly DryIoc.Rules.MicrosoftDependencyInjectionRules -> DryIoc.Rules
~static readonly DryIoc.ServiceDetails.Default -> DryIoc.ServiceDetails
~static readonly DryIoc.ServiceDetails.IfUnresolvedReturnDefault -> DryIoc.ServiceDetails
~static readonly DryIoc.ServiceDetails.IfUnresolvedReturnDefaultIfNotRegistered -> DryIoc.ServiceDetails
~static readonly DryIoc.ServiceInfo.Empty -> DryIoc.IServiceInfo
~static readonly DryIoc.Setup.Decorator -> DryIoc.Setup
~static readonly DryIoc.Setup.Default -> DryIoc.Setup
~static readonly DryIoc.Setup.Wrapper -> DryIoc.Setup
~static readonly DryIoc.ThreadScopeContext.ScopeContextName -> string
~static readonly DryIoc.WrappersSupport.ActionTypes -> System.Type[]
~static readonly DryIoc.WrappersSupport.FuncTypes -> System.Type[]
~static readonly DryIoc.WrappersSupport.SupportedCollectionTypes -> System.Type[]
~static readonly DryIoc.WrappersSupport.Wrappers -> ImTools.ImMap<ImTools.ImMap.KValue<System.Type>>
~static readonly FastExpressionCompiler.LightExpression.Expression.FalseConstant -> FastExpressionCompiler.LightExpression.ConstantExpression
~static readonly FastExpressionCompiler.LightExpression.Expression.NullConstant -> FastExpressionCompiler.LightExpression.ConstantExpression
~static readonly FastExpressionCompiler.LightExpression.Expression.TrueConstant -> FastExpressionCompiler.LightExpression.ConstantExpression
~static readonly FastExpressionCompiler.LightExpression.Expression.ZeroConstant -> FastExpressionCompiler.LightExpression.ConstantExpression
~static readonly FastExpressionCompiler.LightExpression.ExpressionCompiler.EmptyArrayClosure -> FastExpressionCompiler.LightExpression.ExpressionCompiler.ArrayClosure
~static readonly ImTools.ImHashMap<K, V>.Empty -> ImTools.ImHashMap<K, V>
~static readonly ImTools.ImHashMapEntry<K, V>.Empty -> ImTools.ImHashMapEntry<K, V>
~static readonly ImTools.ImList<T>.Empty -> ImTools.ImList<T>
~static readonly ImTools.ImMap<V>.Empty -> ImTools.ImMap<V>
~static readonly ImTools.ImZipper<T>.Empty -> ImTools.ImZipper<T>
~static readonly ImTools.Item<TItem>.Single -> ImTools.Item<TItem>.item
~virtual DryIoc.Factory.ApplyReuse(FastExpressionCompiler.LightExpression.Expression serviceExpr, DryIoc.Request request) -> FastExpressionCompiler.LightExpression.Expression
~virtual DryIoc.Factory.FactoryGenerator.get -> DryIoc.IConcreteFactoryGenerator
~virtual DryIoc.Factory.GetDelegateOrDefault(DryIoc.Request request) -> DryIoc.FactoryDelegate
~virtual DryIoc.Factory.GetExpressionOrDefault(DryIoc.Request request) -> FastExpressionCompiler.LightExpression.Expression
~virtual DryIoc.Factory.ImplementationType.get -> System.Type
~virtual DryIoc.Factory.Made.get -> DryIoc.Made
~virtual DryIoc.Factory.Reuse.get -> DryIoc.IReuse
~virtual DryIoc.Factory.Setup.get -> DryIoc.Setup
~virtual DryIoc.Factory.UseInterpretation(DryIoc.Request request) -> bool
~virtual DryIoc.ParameterServiceInfo.Details.get -> DryIoc.ServiceDetails
~virtual DryIoc.ParameterServiceInfo.ServiceType.get -> System.Type
~virtual DryIoc.PropertyOrFieldServiceInfo.Details.get -> DryIoc.ServiceDetails
~virtual DryIoc.ServiceInfo.Details.get -> DryIoc.ServiceDetails
~virtual DryIoc.Setup.Metadata.get -> object
~virtual FastExpressionCompiler.LightExpression.Expression.Reduce() -> FastExpressionCompiler.LightExpression.Expression
~virtual FastExpressionCompiler.LightExpression.LambdaExpression.Parameters.get -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.ParameterExpression>
~virtual FastExpressionCompiler.LightExpression.MethodCallExpression.Arguments.get -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.Expression>
~virtual FastExpressionCompiler.LightExpression.MethodCallExpression.Object.get -> FastExpressionCompiler.LightExpression.Expression
~virtual FastExpressionCompiler.LightExpression.NewExpression.Arguments.get -> System.Collections.Generic.IReadOnlyList<FastExpressionCompiler.LightExpression.Expression>
~virtual FastExpressionCompiler.LightExpression.UnaryExpression.Method.get -> System.Reflection.MethodInfo
